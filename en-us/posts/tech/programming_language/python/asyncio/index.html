<!doctype html><html lang=en-us dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AsyncIO | Jun's Blog</title>
<meta name=keywords content><meta name=description content="Async concurrency"><meta name=author content="Jun"><link rel=canonical href=https://rich-junwang.github.io/en-us/posts/tech/programming_language/python/asyncio/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://rich-junwang.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://rich-junwang.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://rich-junwang.github.io/img/Q.gif><link rel=apple-touch-icon href=https://rich-junwang.github.io/img/Q.gif><link rel=mask-icon href=https://rich-junwang.github.io/img/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en-us href=https://rich-junwang.github.io/en-us/posts/tech/programming_language/python/asyncio/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script defer src=https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="AsyncIO"><meta property="og:description" content="Async concurrency"><meta property="og:type" content="article"><meta property="og:url" content="https://rich-junwang.github.io/en-us/posts/tech/programming_language/python/asyncio/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-09T12:01:14-07:00"><meta property="article:modified_time" content="2024-08-09T12:01:14-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="AsyncIO"><meta name=twitter:description content="Async concurrency"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"üìöArticles","item":"https://rich-junwang.github.io/en-us/posts/"},{"@type":"ListItem","position":2,"name":"üë®üèª‚Äçüíª Tech","item":"https://rich-junwang.github.io/en-us/posts/tech/"},{"@type":"ListItem","position":3,"name":"AsyncIO","item":"https://rich-junwang.github.io/en-us/posts/tech/programming_language/python/asyncio/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AsyncIO","name":"AsyncIO","description":"Async concurrency","keywords":[""],"articleBody":"Introduction AysncIO in python has two keywords: async/await. Many people who first encounter async concept might wonder isn‚Äôt that python can only have one thread in execution given the constraint of GIL?\nIndeed, ayncio is bound by GIL and it can‚Äôt run more than one task at any moment as is shown below. This means that if another thread needs to run, the ownership of the GIL must be passed from the current executing thread to the other thread. This is what is called preemptive concurrency. This kind of switching is expensive when there are lots of threads.\nThe core concept in asyncio is coroutine. asyncio has its own concurrency synchronization through coroutine. It coordinates task switch with little cost. Simply put, python emulates concurrency in one thread through coroutine using event loop.\nThread and coroutine Coroutine style synchronization still has its overhead, why we would bother switching tasks? The reason is behind the io part in asyncio. Think about that you have the following three tasks:\nTask1: cooking rice takes 40 mins Task2: washing clothes takes 30 mins Task3: dish washing takes 30 mins How much it would take a person to complete all these tasks. It won‚Äôt take us 100 mins for all these tasks because we just need to kick things off and have machines done for us. On the contrary, the following tasks most likely will consume us 100 mins because we have to get involved attentively.\nTask1: watching tv 30 mins Task2: jogging 30 mins Task3: playing video games 40 mins This example is just to illustrate where async ops help in Python ‚Äì only in IO-bound programs such as http requests, file I/O etc, but not in CPU-bound programs. Note that in reality, python won‚Äôt allow us to coordinate the execution of each tasks. We can only pack tasks and send them for async execution.\nimport asyncio import time async def async_task(): now = time.time() await asyncio.sleep(1) print(\"Doing async tasks\") await asyncio.sleep(1) print(time.time() - now) def sync_task(): now = time.time() time.sleep(1) print(\"Doing async tasks\") time.sleep(1) print(time.time() - now) async def main(): # Ê≥®ÊÑèËøôÈáå*Âè∑„ÄÇgatherËá™Âä®Â∞ÜÂáΩÊï∞ÂàóË°®Â∞ÅË£ÖÊàê‰∫ÜÂçèÁ®ã‰ªªÂä°„ÄÇ await asyncio.gather(*[async_task() for _ in range(3)]) now = time.time() # run 3 async_task() coroutine concurrently asyncio.run(main()) print(f\"Time elapsed for running 3 coroutine tasks: {time.time() - now}\") now = time.time() # run 3 sync_task() coroutine concurrently sync_task() sync_task() sync_task() print(f\"Time elapsed for running 3 sync tasks: {time.time() - now}\") How Does it Work Let‚Äôs first have a more formal definition of the two keywords, async and await. From realpython:\nThe syntax async def introduces either a native coroutine or an asynchronous generator. The expressions async with and async for are also valid. The keyword await passes function control back to the event loop. (It suspends the execution of the surrounding coroutine.) If Python encounters an await f() expression in the scope of g(), this is how await tells the event loop, ‚ÄúSuspend execution of g() until whatever I‚Äôm waiting on ‚Äì the result of f() ‚Äì is returned. In the meantime, go let something else run.‚Äù Await can only appear with async functions. Example:\nasync def g(): # Pause here and come back to g() when f() is ready r = await f() return r The event loop is the coordinator of how the coroutine tasks are executed. It is something like a while True loop that monitors coroutines, taking feedback on what‚Äôs idle, and looking around for things that can be executed in the meantime. It is able to wake up an idle coroutine when whatever that coroutine is waiting on becomes available. By default, an async IO event loop runs in a single thread and on a single CPU core.\nHistorically, we have to explicitly create event loop, execute tasks and close the event loop. After Python 3.7, the entire management of the event loop can be implicitly handled by one function call:\nasyncio.run(main()) # Python 3.7+ For instance,\nimport asyncio async def myfunc(i): print(f\"coroutine {i} starting execution\") await asyncio.sleep(2) print(f\"coroutine {i} completes!\") if __name__ == '__main__': asyncio.run(myfunc(1)) Create Tasks and Gather Tasks Old-fashioned way to create task is to use asyncio.create_task method. After creating tasks, we use asyncio.wait to gather all the tasks.\nimport asyncio async def func1(i): print(f\"coroutine {i} starting execution\") await asyncio.sleep(2) print(f\"coroutine {i} completes!\") async def main(): tasks = [] for i in range(1, 5): tasks.append(asyncio.create_task(func1(i))) await asyncio.wait(tasks) if __name__ == '__main__': asyncio.run(main()) To gather tasks, we can also using new gather method. Notice that gather doesn‚Äôt have to use create_task. It can automatically package coroutine into a task.\nimport asyncio async def func1(i): print(f\"coroutine {i} starting execution\") await asyncio.sleep(2) print(f\"coroutine {i} completes!\") async def main(): tasks = [] for i in range(1, 5): # here we're not using create_task tasks.append(func1(i)) # gather creates the coroutine await asyncio.gather(*tasks) if __name__ == '__main__': asyncio.run(main()) Get Results We can use wait to get results.\nimport asyncio async def func1(i): print(f\"coroutine {i} starting execution\") await asyncio.sleep(2) print(f\"coroutine {i} completes!\") async def main(): tasks = [] for i in range(1, 5): tasks.append(asyncio.create_task(func1(i))) # Get execution results done, pending = await asyncio.wait(tasks) for task in done: print(f\"Execution results: {task.result()}\") if __name__ == '__main__': asyncio.run(main()) We can also use gather to get results.\nimport asyncio async def func1(i): print(f\"coroutine {i} starting execution\") await asyncio.sleep(2) print(f\"coroutine {i} completes!\") async def main(): tasks = [] for i in range(1, 5): tasks.append(func1(i)) results = await asyncio.gather(*tasks) for result in results: print(f\"Execution results: {result}\") if __name__ == '__main__': asyncio.run(main()) Difference between asyncio.gather() and asyncio.wait()\nTask wrapping ability asyncio.gather() can wrap regular coroutine functions into tasks automatically. asyncio.wait() cannot do this‚Äîit only accepts a list of already wrapped tasks.\nReturn values asyncio.gather() returns the actual results of coroutine execution. asyncio.wait() returns a tuple: (1) The first element is a set of completed tasks. (2) The second element is a set of pending tasks.\nOrder of results asyncio.gather() preserves the order of results based on the input coroutine list. asyncio.wait() does not guarantee order‚Äîresults come as tasks complete.\nCoroutine, Task and Future Let‚Äôs give some clarifications about the concepts.\nFuture: similar to C++ std::future In C++, std::future acts as a handle for an asynchronous result. The main thread assigns a carrier to a new thread and retrieves a future before continuing its execution. Once the new thread completes, it sets the result on the carrier (e.g., std::promise in C++). The main thread can synchronize by waiting on the future and retrieving the result, even if the worker thread has already exited. In Python, the concurrent.futures module provides a similar Future concept.\nTask: like a thread pool task A task in asyncio is analogous to a task in a thread pool. It represents an asynchronous execution unit, like a function that will run and eventually complete, producing a result.\nCoroutine: Unlike Future and Task, which are primarily used for inter-thread communication (ITC), coroutines are single-threaded. A coroutine can yield execution back to a scheduler, allowing it to manage multiple tasks efficiently. The scheduler saves the context (e.g., call stack, register values, OS signals). It chooses the next coroutine to run and restores the previous coroutine‚Äôs state when it resumes.\nThe role of async/await async/await is used to hint the scheduler about coroutines that are waiting on I/O or other long-running operations. When an async function encounters an I/O-bound task, it yields control to allow other tasks to run in the meantime.\nReferences https://realpython.com/async-io-python/ https://www.roguelynn.com/words/asyncio-we-did-it-wrong/ ","wordCount":"1299","inLanguage":"en-us","datePublished":"2024-08-09T12:01:14-07:00","dateModified":"2024-08-09T12:01:14-07:00","author":[{"@type":"Person","name":"Jun"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://rich-junwang.github.io/en-us/posts/tech/programming_language/python/asyncio/"},"publisher":{"@type":"Organization","name":"Jun's Blog","logo":{"@type":"ImageObject","url":"https://rich-junwang.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rich-junwang.github.io/en-us/ accesskey=h title="Jun's Blog (Alt + H)"><img src=https://rich-junwang.github.io/img/Q.gif alt=logo aria-label=logo height=35>Jun's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://rich-junwang.github.io/en-us/ title="üè† Home"><span>üè† Home</span></a></li><li><a href=https://rich-junwang.github.io/en-us/about title="üôãüèª‚Äç‚ôÇÔ∏è About"><span>üôãüèª‚Äç‚ôÇÔ∏è About</span></a></li><li><a href=https://rich-junwang.github.io/en-us/posts title="üìö Posts"><span>üìö Posts</span></a></li><li><a href=https://rich-junwang.github.io/en-us/tags title="üß© Tags"><span>üß© Tags</span></a></li><li><a href=https://rich-junwang.github.io/en-us/archives/ title="‚è±Ô∏è Archives"><span>‚è±Ô∏è Archives</span></a></li><li><a href=https://rich-junwang.github.io/en-us/search title="üîç Search (Alt + /)" accesskey=/><span>üîç Search</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://rich-junwang.github.io/en-us/>üè† Home</a>&nbsp;¬ª&nbsp;<a href=https://rich-junwang.github.io/en-us/posts/>üìöArticles</a>&nbsp;¬ª&nbsp;<a href=https://rich-junwang.github.io/en-us/posts/tech/>üë®üèª‚Äçüíª Tech</a></div><h1 class=post-title>AsyncIO</h1><div class=post-description>Async concurrency</div><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2024-08-09
&nbsp;&nbsp;
</span></span><span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>1299 words
&nbsp;&nbsp;
</span></span><span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>3 min
&nbsp;&nbsp;
</span></span><span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>Jun
&nbsp;&nbsp;
</span></span><span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta></span></span></span></span><span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;
</span></span><span id=post_meta_style_8><span class="fa fa-commenting-o"></span>
<span><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script><script>let url=document.documentURI,dnsUrl="https://rich-junwang.github.io/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:null,region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#how-does-it-work aria-label="How Does it Work">How Does it Work</a><ul><li><a href=#create-tasks-and-gather-tasks aria-label="Create Tasks and Gather Tasks">Create Tasks and Gather Tasks</a></li><li><a href=#get-results aria-label="Get Results">Get Results</a></li></ul></li><li><a href=#coroutine-task-and-future aria-label="Coroutine, Task and Future">Coroutine, Task and Future</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>AysncIO in python has two keywords: async/await. Many people who first encounter async concept might wonder isn&rsquo;t that python can only have one thread in execution given the constraint of GIL?</p><p>Indeed, ayncio is bound by GIL and it can&rsquo;t run more than one task at any moment as is shown below. This means that if another thread needs to run, the ownership of the GIL must be passed from the current executing thread to the other thread. This is what is called preemptive concurrency. This kind of switching is expensive when there are lots of threads.</p><p>The core concept in asyncio is coroutine. asyncio has its own concurrency synchronization through coroutine. It coordinates task switch with little cost. Simply put, python emulates concurrency in one thread through coroutine using event loop.</p><p align=center><img alt="Thread and coroutine" src=images/image.png width=80%>
<em>Thread and coroutine</em><br></p><p>Coroutine style synchronization still has its overhead, why we would bother switching tasks? The reason is behind the io part in asyncio. Think about that you have the following three tasks:</p><blockquote><ul><li>Task1: cooking rice takes 40 mins</li><li>Task2: washing clothes takes 30 mins</li><li>Task3: dish washing takes 30 mins</li></ul></blockquote><p>How much it would take a person to complete all these tasks. It won&rsquo;t take us 100 mins for all these tasks because we just need to kick things off and have machines done for us. On the contrary, the following tasks most likely will consume us 100 mins because we have to get involved attentively.</p><blockquote><ul><li>Task1: watching tv 30 mins</li><li>Task2: jogging 30 mins</li><li>Task3: playing video games 40 mins</li></ul></blockquote><p>This example is just to illustrate where async ops help in Python &ndash; only in IO-bound programs such as http requests, file I/O etc, but not in CPU-bound programs. Note that in reality, python won&rsquo;t allow us to coordinate the execution of each tasks. We can only pack tasks and send them for async execution.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>async_task</span>():
</span></span><span style=display:flex><span>    now <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Doing async tasks&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print(time<span style=color:#f92672>.</span>time() <span style=color:#f92672>-</span> now)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sync_task</span>():
</span></span><span style=display:flex><span>    now <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Doing async tasks&#34;</span>)
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    print(time<span style=color:#f92672>.</span>time() <span style=color:#f92672>-</span> now)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Ê≥®ÊÑèËøôÈáå*Âè∑„ÄÇgatherËá™Âä®Â∞ÜÂáΩÊï∞ÂàóË°®Â∞ÅË£ÖÊàê‰∫ÜÂçèÁ®ã‰ªªÂä°„ÄÇ</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>[async_task() <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>)])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>now <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span><span style=color:#75715e># run 3 async_task() coroutine concurrently</span>
</span></span><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Time elapsed for running 3 coroutine tasks: </span><span style=color:#e6db74>{</span>time<span style=color:#f92672>.</span>time() <span style=color:#f92672>-</span> now<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>now <span style=color:#f92672>=</span> time<span style=color:#f92672>.</span>time()
</span></span><span style=display:flex><span><span style=color:#75715e># run 3 sync_task() coroutine concurrently</span>
</span></span><span style=display:flex><span>sync_task()
</span></span><span style=display:flex><span>sync_task()
</span></span><span style=display:flex><span>sync_task()
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Time elapsed for running 3 sync tasks: </span><span style=color:#e6db74>{</span>time<span style=color:#f92672>.</span>time() <span style=color:#f92672>-</span> now<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><h2 id=how-does-it-work>How Does it Work<a hidden class=anchor aria-hidden=true href=#how-does-it-work>#</a></h2><p>Let&rsquo;s first have a more formal definition of the two keywords, async and await. From realpython:</p><blockquote><ul><li>The syntax async def introduces either a native coroutine or an asynchronous generator. The expressions async with and async for are also valid.</li><li>The keyword await passes function control back to the event loop. (It suspends the execution of the surrounding coroutine.) If Python encounters an await f() expression in the scope of g(), this is how await tells the event loop, ‚ÄúSuspend execution of g() until whatever I‚Äôm waiting on &ndash; the result of f() &ndash; is returned. In the meantime, go let something else run.‚Äù Await can only appear with async functions.</li></ul></blockquote><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>g</span>():
</span></span><span style=display:flex><span><span style=color:#75715e># Pause here and come back to g() when f() is ready</span>
</span></span><span style=display:flex><span>    r <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> f()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r
</span></span></code></pre></div><p>The event loop is the coordinator of how the coroutine tasks are executed. It is something like a while True loop that monitors coroutines, taking feedback on what‚Äôs idle, and looking around for things that can be executed in the meantime. It is able to wake up an idle coroutine when whatever that coroutine is waiting on becomes available. By default, an async IO event loop runs in a single thread and on a single CPU core.</p><p>Historically, we have to explicitly create event loop, execute tasks and close the event loop. After Python 3.7, the entire management of the event loop can be implicitly handled by one function call:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>asyncio<span style=color:#f92672>.</span>run(main())  <span style=color:#75715e># Python 3.7+</span>
</span></span></code></pre></div><p>For instance,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>myfunc</span>(i):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> starting execution&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> completes!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(myfunc(<span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><h3 id=create-tasks-and-gather-tasks>Create Tasks and Gather Tasks<a hidden class=anchor aria-hidden=true href=#create-tasks-and-gather-tasks>#</a></h3><p>Old-fashioned way to create task is to use <code>asyncio.create_task</code> method. After creating tasks, we use asyncio.wait to gather all the tasks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>func1</span>(i):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> starting execution&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> completes!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    tasks <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>        tasks<span style=color:#f92672>.</span>append(asyncio<span style=color:#f92672>.</span>create_task(func1(i)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>wait(tasks)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>To gather tasks, we can also using new <code>gather</code> method. Notice that gather doesn&rsquo;t have to use <code>create_task</code>. It can automatically package coroutine into a task.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>func1</span>(i):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> starting execution&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> completes!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    tasks <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># here we&#39;re not using create_task</span>
</span></span><span style=display:flex><span>        tasks<span style=color:#f92672>.</span>append(func1(i))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># gather creates the coroutine</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>tasks)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><h3 id=get-results>Get Results<a hidden class=anchor aria-hidden=true href=#get-results>#</a></h3><p>We can use wait to get results.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>func1</span>(i):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> starting execution&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> completes!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    tasks <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>        tasks<span style=color:#f92672>.</span>append(asyncio<span style=color:#f92672>.</span>create_task(func1(i)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get execution results</span>
</span></span><span style=display:flex><span>    done, pending <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>wait(tasks)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> task <span style=color:#f92672>in</span> done:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Execution results: </span><span style=color:#e6db74>{</span>task<span style=color:#f92672>.</span>result()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>We can also use gather to get results.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> asyncio
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>func1</span>(i):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> starting execution&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;coroutine </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> completes!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    tasks <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>        tasks<span style=color:#f92672>.</span>append(func1(i))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    results <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> asyncio<span style=color:#f92672>.</span>gather(<span style=color:#f92672>*</span>tasks)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> result <span style=color:#f92672>in</span> results:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Execution results: </span><span style=color:#e6db74>{</span>result<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    asyncio<span style=color:#f92672>.</span>run(main())
</span></span></code></pre></div><p>Difference between asyncio.gather() and asyncio.wait()</p><ol><li><p>Task wrapping ability
asyncio.gather() can wrap regular coroutine functions into tasks automatically.
asyncio.wait() cannot do this‚Äîit only accepts a list of already wrapped tasks.</p></li><li><p>Return values
asyncio.gather() returns the actual results of coroutine execution.
asyncio.wait() returns a tuple: (1) The first element is a set of completed tasks. (2) The second element is a set of pending tasks.</p></li><li><p>Order of results
asyncio.gather() preserves the order of results based on the input coroutine list.
asyncio.wait() does not guarantee order‚Äîresults come as tasks complete.</p></li></ol><h2 id=coroutine-task-and-future>Coroutine, Task and Future<a hidden class=anchor aria-hidden=true href=#coroutine-task-and-future>#</a></h2><p>Let&rsquo;s give some clarifications about the concepts.</p><ol><li><p>Future: similar to C++ std::future
In C++, std::future acts as a handle for an asynchronous result. The main thread assigns a carrier to a new thread and retrieves a future before continuing its execution.
Once the new thread completes, it sets the result on the carrier (e.g., std::promise in C++). The main thread can synchronize by waiting on the future and retrieving the result, even if the worker thread has already exited. In Python, the concurrent.futures module provides a similar Future concept.</p></li><li><p>Task: like a thread pool task
A task in asyncio is analogous to a task in a thread pool. It represents an asynchronous execution unit, like a function that will run and eventually complete, producing a result.</p></li><li><p>Coroutine:
Unlike Future and Task, which are primarily used for inter-thread communication (ITC), coroutines are single-threaded. A coroutine can yield execution back to a scheduler, allowing it to manage multiple tasks efficiently. The scheduler saves the context (e.g., call stack, register values, OS signals). It chooses the next coroutine to run and restores the previous coroutine‚Äôs state when it resumes.</p></li><li><p>The role of async/await
async/await is used to hint the scheduler about coroutines that are waiting on I/O or other long-running operations. When an async function encounters an I/O-bound task, it yields control to allow other tasks to run in the meantime.</p></li></ol><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ol><li><a href=https://realpython.com/async-io-python/>https://realpython.com/async-io-python/</a></li><li><a href=https://www.roguelynn.com/words/asyncio-we-did-it-wrong/>https://www.roguelynn.com/words/asyncio-we-did-it-wrong/</a></li></ol></div><footer class=post-footer><nav class=paginav><a class=prev href=https://rich-junwang.github.io/en-us/posts/tech/llm/llm_inference/vllm/><span class=title>¬´</span><br><span>vLLM</span>
</a><a class=next href=https://rich-junwang.github.io/en-us/posts/tech/ml/rl/verl/><span class=title>¬ª</span><br><span>veRL</span></a></nav></footer></div><style>.comments_details summary::marker{font-size:20px;content:'üëâComment';color:var(--content)}.comments_details[open] summary::marker{font-size:20px;content:'üëáCollapse';color:var(--content)}</style><div><details class=comments_details><summary style="cursor:pointer;margin:50px 0 20px;width:130px"><span style=font-size:20px;color:var(--content)>...</span></summary><div id=tcomment></div></details><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script><script>twikoo.init({envId:null,el:"#tcomment",lang:"en-us",region:null,path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>Copyright
&copy;
2020-2025
<a href=https://rich-junwang.github.io/en-us/ style=color:#939393>Jun's Blog</a>
All Rights Reserved
</span><a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;
<span id=busuanzi_container><span class="fa fa-user"></span> <span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye"></span> <span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString()+`\r

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\r
ÁâàÊùÉÂ£∞ÊòéÔºöÊú¨Êñá‰∏∫„ÄåJun's Blog„ÄçÁöÑÂéüÂàõÊñáÁ´†ÔºåÈÅµÂæ™CC 4.0 BY-SAÁâàÊùÉÂçèËÆÆÔºåËΩ¨ËΩΩËØ∑ÈôÑ‰∏äÂéüÊñáÂá∫Â§ÑÈìæÊé•ÂèäÊú¨Â£∞Êòé„ÄÇ\r
ÂéüÊñáÈìæÊé•Ôºö`+location.href,s=window.getSelection().toString()+`\r

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\r
ÁâàÊùÉÂ£∞ÊòéÔºöÊú¨Êñá‰∏∫„ÄåJun's Blog„ÄçÁöÑÂéüÂàõÊñáÁ´†ÔºåÈÅµÂæ™CC 4.0 BY-SAÁâàÊùÉÂçèËÆÆÔºåËΩ¨ËΩΩËØ∑ÈôÑ‰∏äÂéüÊñáÂá∫Â§ÑÈìæÊé•ÂèäÊú¨Â£∞Êòé„ÄÇ\r
ÂéüÊñáÈìæÊé•Ôºö`+location.href;t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function i(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent+`\r
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\r
ÁâàÊùÉÂ£∞ÊòéÔºöÊú¨Êñá‰∏∫„ÄåJun's Blog„ÄçÁöÑÂéüÂàõÊñáÁ´†ÔºåÈÅµÂæ™CC 4.0 BY-SAÁâàÊùÉÂçèËÆÆÔºåËΩ¨ËΩΩËØ∑ÈôÑ‰∏äÂéüÊñáÂá∫Â§ÑÈìæÊé•ÂèäÊú¨Â£∞Êòé„ÄÇ\r
ÂéüÊñáÈìæÊé•Ôºö`+location.href;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>
[{"content":"In this blog, I\u0026rsquo;ll go through the theory (simplified version) of PPO algorithm and try to code it from scratch.\nBasics Monte Carlo Approximation Distributions of random variables in reality are mostly unknown. Sampling-based methods are extensively used in practice becaue of its ease of use and the generality where they can be applied. One of the fundamental problems is to calculate the expectation of a random variable, which can be expressed as\n$$ \\mathbb{E_{x\\sim p(x)}}\\left(f(x)\\right) = \\int{f(x)p(x)} dx $$ when it\u0026rsquo;s a continuous random variable with a probability density function of $p$, or $$ \\mathbb{E}\\left(f(x)\\right) = \\sum_x{f(x)p(x)} $$ when it\u0026rsquo;s a discrete random variable with probability mass function of $p$. Then the Monte Carlo approximation says that the expectation is: $$ \\mathbb{E}\\left(f(x)\\right) \\approx \\frac{1}{N}\\sum_{i=1}^{N}{f(x_i)} $$\nassuming that the $x_i$ here is the i.i.d samples from the distribution $p(x)$.\nImportance Sampling In reality, it could be very challenging to sample data according to the distribution $p(x)$ as it is usually unknown to us. A workaround is to have another known distribution $q(x)$, and define the expectation as: $$ \\mathbb{E_{x\\sim p(x)}}[f] = \\int{q(x)\\frac{p(x)}{q(x)}f(x)} dx $$ This can be seen as the expectation of function $\\frac{p(x)}{q(x)}f(x)$ according to the distribution of $q(x)$. The distribution is sometimes called the proposal distribution. Then the expectation can be estimated as $$ \\mathbb{E_{x\\sim q(x)}}[f] \\approx \\frac{1}{N}\\sum_{i=1}^{N}{\\frac{p(x_i)}{q(x_i)}f(x_i)} $$ Here the ratios $\\frac{p(x_i)}{q(x_i)}$ are referred sa the importance weights. The above derivation looks nice. However, we need to notice that the although the expectation is similar in both cases, the variance is different:\n$$ Var_{x\\sim p(x)}[f] = \\mathbb{E_{x\\sim p(x)}}[f(x)^2] - ({\\mathbb{E_{x\\sim p(x)}}[f(x)]})^2 $$\n$$ \\begin{aligned} Var_{x\\sim q(x)}[f] \u0026amp;= \\mathbb{E_{x\\sim q(x)}}[({\\frac{p(x_i)}{q(x_i)}f(x_i)})^2] - (\\mathbb{E_{x\\sim q(x)}}[{\\frac{p(x_i)}{q(x_i)}f(x_i)}])^2 \\\\ \u0026amp;= \\mathbb{E_{x\\sim p(x)}}[{\\frac{p(x_i)}{q(x_i)}f(x_i)^2}] - (\\mathbb{E_{x\\sim p(x)}}[f(x_i)])^2 \\end{aligned} $$ Notice that the second equation here, in the second step derivation, the expectation is relative to distribution of $p(x)$. From the above two equations, we can see that to make the sampling distribution as close as possible to the original distribution, the ratio $\\frac{p(x_i)}{q(x_i)}$ has to be close to 1.\nPolicy Gradient First, let\u0026rsquo;s remind ourselves some basics. The discounted return for a trajectory is defined as: $$ U_t = R_t + \\gamma R_{t+1} + \\gamma^2 R_{t+2} + \\gamma^3 R_{t+3} + \u0026hellip; $$\nConsequently, the action-value function is defined as $$ Q_{\\pi}(s_t, a_t) = \\mathbb{E_t}[U_t|S_t=s_t, A_t=a_t] $$\nState-value function can be calculated as: $$ V_{\\pi}(s_t) = \\mathbb{E_A}[Q_{\\pi}(s_t, A)] = \\sum_a \\pi(a|s_t) \\cdot Q_{\\pi}(s_t, a) $$\nIn policy gradient algorithm, the policy function $\\pi(a|s_t)$ is approximated by policy network $\\pi(a|s_t; \\theta)$. $\\theta$ here is the neural network model parameters. Then the policy-based learning is to maximize the objective function $$ \\begin{aligned} J(\\theta) \u0026amp;= \\mathbb{E_S}[V(S; \\theta)] \\\\ \u0026amp;= \\sum_{s\\in S} d_{\\pi}(s) V_{\\pi}(s_t; \\theta) \\\\ \u0026amp;= \\sum_{s\\in S} d_{\\pi}(s) \\sum_a \\pi(a|s_t; \\theta) \\cdot Q_{\\pi}(s_t, a) \\end{aligned} $$\nwhere $d_{\\pi}(s)$ is the stationary distribution of Markov chain for $\\pi_{\\theta}$, namely the state distribution under policy $\\pi$. Now we know the objective function of the policy-based algorithm, we can learn the parameters $\\theta$ through policy gradiet ascent.\nNow we can look at how to get the policy gradient. Since the first summation of the last step in the above equation has nothing to do with $\\theta$, so we can focus on getting the derivatives of the value function $V_{\\pi}(s; \\theta)$. Using chain rule, it\u0026rsquo;s easy to get: $$ \\begin{aligned} \\frac{\\partial{V(s; \\theta)}}{\\partial{\\theta}} \u0026amp;= \\sum_a \\frac{\\partial{\\pi (a|s; \\theta)}}{\\partial{\\theta}} \\cdot Q_{\\pi}(s, a) \\\\ \u0026amp;= \\sum_a \\pi(a|s_t; \\theta) \\frac{\\partial{\\log\\pi (a|s; \\theta)}}{\\partial{\\theta}} \\cdot Q_{\\pi}(s, a) \\\\ \u0026amp;= \\mathbb{E_A}\\left[ \\frac{\\partial{\\log\\pi (a|s; \\theta)}}{\\partial{\\theta}} \\cdot Q_{\\pi}(s, a) \\right] \\end{aligned} $$ The last step assumes that $\\frac{\\partial{\\log\\pi (a|s; \\theta)}}{\\partial{\\theta}} \\cdot Q_{\\pi}(s, a)$ follows a distribution of $\\pi(a|s_t; \\theta)$ with respect to the random variable $A$.\nThe above equation is the vanilla policy gradient method. More policy gradient algorithms are proposed later to reduce high variance of the vanilla version. John Schulman\u0026rsquo;s GAE paper summarized all the improvement methods. In the derivation, the policy gradient is represented as $$ \\frac{\\partial{V(s; \\theta)}}{\\partial{\\theta}} = \\mathbb{E_A}\\left[ \\frac{\\partial{\\log\\pi (a|s; \\theta)}}{\\partial{\\theta}} \\cdot \\hat{A_t}(s, a) \\right] $$ where $\\hat{A_t}(s, a)$ is the advantage function. In implementation, we construct loss function in a way such that the policy gradient $g$ equals to the above result $$ L(\\theta) = \\mathbb{E_t}\\left[ \\log\\pi (a|s; \\theta) \\hat{A_t}(s, a) \\right] $$\nActor-Critic Algorithm There we give a recap of how actor-critic method works. In Actor-Critic algorithm, we use one neural network $\\pi(a|s; \\theta)$ to approximate policy function $\\pi(a|s)$ and use another neural network $q(s, a; w)$ to approximate value function $Q_{\\pi}(s, a)$.\nObserve state $s_t$, and randomly sample action from policy $a_t \\sim \\pi(\\cdot | s_t; \\Theta_t)$ Let agent perform action $a_t$, and get new state $s_{t+1}$ and reward $r_t$ from environment Randomly sample $\\tilde{a}_{t+1} \\sim \\pi(\\cdot | s_t; \\Theta_t)$ without performing the action Evaluate value network: $q_t = q(s_t, a_t; W_t)$ and $q_{t+1} = q(s_{t+1}, \\tilde{a}_{t+1}; W_t)$ Compute TD error: $\\delta_t = q_t - (r_t + \\gamma \\cdot q_{t+1})$ Differentiate value network: $d_{w,t} = \\frac{\\partial{q(s_t, a_t, w)}}{\\partial{w}}$ (autograd will do this for us) Update value network: $ w_{t+1} = w_t - \\alpha \\cdot \\delta_t \\cdot d_{w, t}$ Differentiate policy network: $ d_{\\theta, t} = \\frac{\\partial{\\log\\pi (a|s; \\theta)}}{\\partial{\\theta}} $ (again autograd will do this for us) Update policy network: $\\theta_{t+1} = \\theta_t + \\beta \\cdot q_t \\cdot d_{\\theta, t}$. We can also use: $\\theta_{t+1} = \\theta_t + \\beta \\cdot \\delta_t \\cdot d_{\\theta, t}$ to update policy network. This is called policy gradient with baseline. Essentially, the algorithm alternates between sampling and optimization. The expectation in the above equation indicates that we need to average over a finite batch of empirical samples. Proximal Policy Optimization Vanilla policy gradient method uses on-policy update. Concretely, the algorithm samples empirical data from a policy network $\\pi_{\\theta}$ parameterized with $\\theta$. After updating the network itself, the new policy network is $\\pi_{\\theta_{new}}$ and the old policy $\\pi_{\\theta}$ is out of use and future sampling will be from $\\pi_{\\theta_{new}}$. This whole process is not efficient enough. The solution to this is to reuse the old samples to achieve off-policy training. From above importance sampling section, we know that:\n$$ \\mathbb{E_{x\\sim p(x)}}\\left[f \\right] = \\mathbb{E_{x\\sim q(x)}} \\left[ \\frac{p(x_i)}{q(x_i)}f(x_i) \\right] $$\nSimilarly, we can make a change to the objective function of our policy gradient, and the resulting policy gradient will become $$ \\begin{aligned} g \u0026amp;= \\mathbb{E_{{(s_t, a_t)} \\sim \\pi_{\\theta}}}\\left[ \\frac{\\partial{\\log\\pi (a_t|s_t; \\theta)}}{\\partial{\\theta}} \\cdot \\hat{A_t}(s, a) \\right] \\\\ \u0026amp;= \\mathbb{E_{{(s_t, a_t)} \\sim \\pi_{\\theta_{old}}}}\\left[ \\frac{\\pi_{\\theta}(a_t|s_t; \\theta)}{\\pi_{\\theta_{old}}(a_t|s_t)} \\frac{\\partial{\\log\\pi (a_t|s_t; \\theta)}}{\\partial{\\theta}} \\cdot \\hat{A_t}(s, a) \\right] \\end{aligned} $$ Consequently, the loss becomes\n$$ L(\\theta) = \\mathbb{E_{{(s_t, a_t)} \\sim \\pi_{\\theta_{old}}}}\\left[ \\frac{\\pi_{\\theta}(a_t|s_t)}{\\pi_{\\theta_{old}}(a_t|s_t)} \\hat{A_t}(s, a) \\right] $$ This is so-called surrogate objective function. In the above section, we mentioned how to use chain rule to get the expectation format of gradient, here we just to reverse the process to get the above loss function.\nIn the importance sampling section, we saw that the variance of new distribution could be large when the proposal distribution is not so close to the original distribution. Thus, to deal with this, people add KL diveragence to the loss function to limit the old and new policy difference. Using Largrangian dual method, we can add this constraint to the objective function:\n$$ L(\\theta) = \\mathbb{E_{{(s_t, a_t)} \\sim \\pi_{\\theta_{old}}}}\\left[ \\frac{\\pi_{\\theta}(a_t|s_t)}{\\pi_{\\theta_{old}}(a_t|s_t)} \\hat{A_t}(s, a) - \\beta KL[\\pi_{\\theta_{old}}(a_t|s_t), \\pi_{\\theta}(a_t|s_t)]\\right] $$\nReferences [1] High-Dimensional Continuous Control Using Generalized Advantage Estimation [2] Proximal Policy Optimization Algorithms [3] Policy Gradient Methods for Reinforcement Learning with Function Approximation [4] Dueling Network Architectures for Deep Reinforcement Learning [5] https://cs.uwaterloo.ca/~ppoupart/teaching/cs885-spring18/schedule.html [6] https://github.com/wangshusen/DRL [7] https://www.davidsilver.uk/teaching/ [8] Fine-Tuning Language Models from Human Preferences ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/ppo/","summary":"In this blog, I\u0026rsquo;ll go through the theory (simplified version) of PPO algorithm and try to code it from scratch. Basics Monte Carlo Approximation Distributions of random variables in reality are mostly unknown. Sampling-based methods are extensively used in practice becaue of its ease of use and the generality where they can be applied. One of the fundamental problems is to calculate the expectation of a random variable, which can be expressed as $$ \\mathbb{E_{x\\sim p(x)}}\\left(f(x)\\right) = \\int{f(x)p(x)} dx $$ when it\u0026rsquo;s a continuous random variable with a probability density function of $p$, or $$ \\mathbb{E}\\left(f(x)\\right) = \\sum_x{f(x)p(x)} $$ when it\u0026rsquo;s a discrete random variable with probability mass function of $p$. Then the Monte Carlo approximation says that the expectation is: $$ \\mathbb{E}\\left(f(x)\\right) \\approx \\frac{1}{N}\\sum_{i=1}^{N}{f(x_i)} $$ assuming that the $x_i$ here is the i.i.d samples from the distribution $p(x)$. Importance","title":"PPO and Its Implementation"},{"content":"In order to understand how flash attention and its variants help improve compute efficiency of modern LLMs training, we first have to dive deep into GPU compute model and its memory hierarchy.\nGPU Compute Model and Memory Hierarchy The Figure 1 here shows the high level compute model and memory in GPU. We can see that there are three types of memory affect GPU computation. CPU memory (data loading etc), GPU high bandwidth memory (the gpu memory we usually mentioned), and GPU caches (SRAM). These memories are of different size and bandwidth (read speed). The idea of flash attention is to design IO-aware fused computation kernel to save memory access to speed up training job.\nFigure 1. GPU memory Figure 2 shows a more detailed hierarchy of GPU memory in A100. Notice that cache is specific to each compute unit.\nFigure 2. GPU memory hierarchy IO-aware Computation First let\u0026rsquo;s take a look at the vallina attention computation which is shown below\nFigure 3. Vallina attention computation Essentially, each of the operation follows the three steps of operation below.\nRead op — Move tensor from HBM to SRAM Compute op - Perform compute intensive task on SRAM write op - move tensor back from SRAM to HBM The breakdown of these computation is as follows. Apparently, all these green ops in the vallina attention can be saved.\nFigure 4. Vallina attention computation break down However, it\u0026rsquo;s hard to put giant attention matrix of size [N x N] in the cache. The idea to solve this challenge is to use tiling. Concretely, we slice the matrices into smaller blocks and in each of Q K computation, we do it in a small block scale. The output of the small block thus can be saved on the cache. This sounds perfectly except that softmax op is not possible with small block computation. Lucklily there are already some studies dealing with this [1-2]. Before talking about this, let\u0026rsquo;s first revisit stable softmax computation.\nBlockwise Softmax Underflow in numerical computation can cause precision issue. Overflow can be more problematic because it usually leads to divergence of training job (some may argue silent error is more detrimental :)). Softmax operation involves exponential computation which without careful handling can easily lead to overflow (such as exp(2000)).\n$$ \\text{softmax}(x)_i = \\frac{e^{x_i - \\max(x)}}{\\sum_j e^{x_j - \\max(x)}} $$\nSimilary, the cross entropy can be computed as\n$$ \\begin{aligned} H(p, q) \u0026amp;= -\\sum_i p_i\\log(q_i) \\\\ \u0026amp;= -1\\cdot\\log(q_y) -\\sum_{i \\neq y} 0\\cdot\\log(q_i) \\\\ \u0026amp;= -\\log(q_y) \\\\ \u0026amp;= -\\log(\\text{softmax}(\\hat{y})_y) \\\\ \\end{aligned} $$\n$$ \\begin{aligned} \\log(\\text{softmax}(x)_i) \u0026amp;= \\log(\\frac{e^{x_i - \\max(x)}}{\\sum_j e^{x_j - \\max(x)}}) \\\\ \u0026amp;= x_i - \\max(x) - \\log(\\sum_j e^{x_j - \\max(x)}) \\end{aligned} $$\nBy simply extracting the max value, we limit the exponential values to be in [0, 1]. In Flashattention paper, the softmax is represented as follows:\nFigure 5. Softmax Then blockwise softmax can be computed as follows:\nFigure 6. Blockwise Softmax With saving some summary (i.e. max) statistics, the softmax op can be decomposed into blocks.\nRecomputation in Backpropagation With the fused kernel, we effectively do the computation outside Pytorch computation graph. Thus, we can\u0026rsquo;t use the AutoGrad for gradient computation in backpropagation. Consequently, we have to define the backpropagation by ourselves. The way to solve this is very simple as well. We just define our own backpropagation ops for fused kernel like gradient checkpointing.\nReferences [1] SELF-ATTENTION DOES NOT NEED O(n^2) MEMORY [2] Online normalizer calculation for softmax [3] FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness\n","permalink":"https://rich-junwang.github.io/en-us/posts/tech/flash_attn/","summary":"In order to understand how flash attention and its variants help improve compute efficiency of modern LLMs training, we first have to dive deep into GPU compute model and its memory hierarchy. GPU Compute Model and Memory Hierarchy The Figure 1 here shows the high level compute model and memory in GPU. We can see that there are three types of memory affect GPU computation. CPU memory (data loading etc), GPU high bandwidth memory (the gpu memory we usually mentioned), and GPU caches (SRAM). These memories are of different size and bandwidth (read speed). The idea of flash attention is to design IO-aware fused computation kernel to save memory access to speed up training job. Figure 1. GPU memory Figure 2 shows a more detailed hierarchy of GPU memory in A100. Notice that cache is specific to each compute unit.","title":"Flash Attention"},{"content":"Recently ChatGPT model has demonstrated remarkable success of large pretrained language model being able to generate coherent, logical and meaningful conversations. While as of this writing, the corresponding paper is still not available yet. In this blog, I\u0026rsquo;ll dive deep into InstructGPT model to see what\u0026rsquo;s under the hood of this model.\nIssues with Traditional LM Language modeling objective is trying to predict next token given all previous tokens. However, when we\u0026rsquo;re prompting LM in inference time, we hope LM can generate things based on our instructions/intent instead of merely predicting the most likely tokens. This is the so-called misalignment between training and inference.\nSolution Using reinforcement learning to learn human feedback. For this purpose, they have to collect a dataset. The way to collect the dataset is as follows:\nselect some contract labeler collect human written prompt-answer pairs. Prompts are either from GPT3 API or from human annotation. collect a dataset of human-labeled comparisons between outputs from our models on a larger set of API prompts. The following diagram from the paper demonstrated how these steps unfold during the training.\nIn summary, there are three steps:\nUse labeled data to fine-tune GPT3 model Train a reward model Use RL to optimize GPT3 parameters In the first step, we got data from annotators and use this data to fine-tune GPT3 model. In the second step, they prepare some questions and GPT3 model gives multiple predictions for each question and annotators are asked to rank the generated predictions. This data is used to train reward model. The reward model is used for prediction and predict which one is most close to human choice. Reward model gives a score and the closer to human choice, the higher of the score.\nFinally, use policy-based RM algorithm to do further optimization. The whole process is shown in the diagram below. It uses reward mechanism to train model. The reward can be seen as the loss function in traditional ML training. Reward function is much more versatile than loss function (Think about DotaRL and AlphaGo). The consequence is that reward function may not be differentiable, thus can\u0026rsquo;t be used for back-propagation. People can sample rewards to proximate this loss function.\nRL algorithm. Image from [4] PPO From the repo in [4], the three steps of PPO are as follows:\nRollout: The language model generates a response or continuation based on query which could be the start of a sentence. Evaluation: The query and response are evaluated with a function, model, human feedback or some combination of them. The important thing is that this process should yield a scalar value for each query/response pair. Optimization: In the optimisation step the query/response pairs are used to calculate the log-probabilities of the tokens in the sequences. This is done with the model that is trained and and a reference model, which is usually the pre-trained model before fine-tuning. The KL-divergence between the two outputs is used as an additional reward signal to make sure the generated responses don\u0026rsquo;t deviate to far from the reference language model. The active language model is then trained with PPO. (To be continued)\nReferences [1] Learning to summarize from human feedback [2] InstructGPT: Training language models to follow instructions with human feedback [3] Fine-Tuning Language Models from Human Preferences [4] https://github.com/lvwerra/trl [5] https://zhuanlan.zhihu.com/p/590311003 [6] Super-natural instructions: generalization via declarative instructions on 1600+ NLP tasks [7] Training a Helpful and Harmless Assistant with Reinforcement Learning from Human Feedback\n","permalink":"https://rich-junwang.github.io/en-us/posts/tech/instructgpt/","summary":"Recently ChatGPT model has demonstrated remarkable success of large pretrained language model being able to generate coherent, logical and meaningful conversations. While as of this writing, the corresponding paper is still not available yet. In this blog, I\u0026rsquo;ll dive deep into InstructGPT model to see what\u0026rsquo;s under the hood of this model. Issues with Traditional LM Language modeling objective is trying to predict next token given all previous tokens. However, when we\u0026rsquo;re prompting LM in inference time, we hope LM can generate things based on our instructions/intent instead of merely predicting the most likely tokens. This is the so-called misalignment between training and inference. Solution Using reinforcement learning to learn human feedback. For this purpose, they have to collect a dataset. The way to collect the dataset is as follows: select some contract labeler collect human written prompt-answer pairs. Prompts","title":"InstructGPT and ChatGPT"},{"content":"Large language model pretraining is a very challenging task which requires very strong engineering and science skills. People tend to underestimate efforts needed to train a good large model like GPT3 etc. Most people imagine that they can get decent language models given enough computation resources. The fact is even today only OpenAI is providing LM APIs where people can freely play with and get good performances. In this blog, we\u0026rsquo;ll talk about pretraining from the whole pipeline: data sourcing, collection and processing, tokenization, architecture engineering and evaluation. Hopefully, it would be helpful for foundational model training practioners.\nData Data is crucial in any ML system. This is true to pretraining as well. As is shown in Gopher paper, a large, diverse and high-quality dataset is needed to train a good model. In the following table, it shows the datasets used in Gopher model training. Now we\u0026rsquo;re looking at terabytes scale of training data.\nDatasets used in Gopher [2] An ensuing problem with large amount of data is that data quality is hard to control. In practice, we have to at least make sure the content should be intelligible. We might want to give more training on high-quality datasets such as books and wikipedia [31]. Diversified datasets are necessary but can't guarantee training success as can be seen from `Gopher` paper, model performs well on QA related tasks but suffers on reasoning task. What else is needed? We'll come back to this later. Toxicity Filter There is experiment shows that toxicity filter could have a big impact on model performance. In [37], the authors proposed that instead of using a toxicity filter, inverse toxicity filtering is more helpful. Inverse toxicity filter removes the LEAST toxicity data from training data.\nTokenizer Language models compute probability of any string sequence. How to represent the string sequence is determined by tokenizer. Popular options are byte pair encoding (BPE) or wordpiece. As the majority of models are using BPE today, here we focus on BPE based tokenizer. Tokenizer can impact several things in LLM training: (1) a high compression rate (tokenized token numer vs raw token number, the lower the better). Compression rate affects input context length and inference speed. (2) Vocab size. An appropriately sized vocabulary to ensure adequate training of each word embedding.\nAs mentioned in GPT2 paper, BPE effectively interpolates between word level inputs for frequent symbol sequences and character level inputs for infrequent symbol sequences. Directly using greedy method to build BPE merging rules can be problematic. For example, word cat can be used in a lot of places like cat?, cat!, cat.. One way to solve this issue is to prevent BPE from generating rules across different character categories (letters, digits, puncts etc).\nAs people are pivoting in-context learing/instruction learning with large models, tokenization efficiency becomes more important. The following tables from Jurassic-1 paper shows the efficiency of tokenizer on several public dataset.\nTokenizer efficiency comparison from [16] Tokenizer determines the size of vocab. Usually when we support multilinguality and code data, the vocab size will be much larger. However, this is not always the case. CodeLLaMa shows very good performance (onpar with GPT4) with a vocab size of 32k. When vocab is too large, some of the tokens may not be trained enough. When vocab size is too small, the compression rate might be limited.\nCompression rate determines the input sequence length to the model. With high compression rate, the input length is shorter. Short sequence length might be able to mitigate exposure bias to some extent.\nOpen tokenizer implementations are: tiktoken.\nModel Architecture All pretrained models are variant of original transformer model. The differences are mainly about it\u0026rsquo;s encoder-decoder architecture or decoder-only architecture. First of all, let\u0026rsquo;s take a look at the choices of available large models.\nModels Model Size Token Size Architecture GPT3 175B 300B Decoder OPT 175B 300B Decoder PaLM 540B 780B Decoder Gopher 280B 300B Decoder Chinchilla 70B 1400B Decoder Jurassic-1 178B - Decoder Megatron-Turing NLG 530B 270B Decoder LaMDA 137B 2810B Decoder Although all models listed here are autoregressive decoder only model, they actually differ a bit inside the decoder. For instance, to speed up inference time, PaLM is using multi-query attention. Normally, in mutlhead attention, there will be h heads each with a linear project layer for Q, K, V. With multiquery attention, instead of using h different linear project layers for K and V, we can share a single smaller linear project layer for K and a single linear projection layer for V for each head. Then, for different head layers, K and V will be the same. In this way, we can save memory IO and get better latency performance in incremental inference.\nA systematic study of transformer architecture is done in Ref [29]. Most of recent LLM architecture are following design from this paper.\nPeople usually call the embedding dim as the width of transformer and number of layers as the depth. There is a optimal depth-to-width allocation for a given self-attention network size as is shown in [34].\nTraining Design Most of today\u0026rsquo;s pretraining follow suits of a multi-stage and multi-task training. As is shown by Yao in [1], GPT series model is pretrained in such way as well.\nGPT Model Lineage. Image from [1] From the lineage diagram, we can see that ChatGPT model comes from Codex model which can be seen as a different stage of training. The way of scheduling tasks and data during training can have great impact on the final model performance.\nBatch Size Research [5] shows that there is a critical batch size in pretraining. When training batch size exceeds critical batch size, model performance starts to degrade. Critical batch size is independent of model size and is related to loss.\nGenerally small batch size leads to better validation loss when training with the same number of tokens as more random movement of gradient explores more of loss landscape. Often times, small batch size gives better genelization performance as well as pointed out in [27]. The reason given from the paper is that smaller batch size usually converges to flat minimum as oppose to sharp minimum. Intuitively, this is related to graident update in each step is small for large batch size training.\nFlat and Sharp Minima [27] Learning Rate Scheduling Usually as pointed out in [20], when we scale up batch size, we increase learning rate propotionally. However, when we increase model size (usually followed with batch size increase), the training tends to be more unstable. Thus, in reality, we decrease maximum learning rate when we increase model size (batch size).\nLearning rate scheduling usually involves a (linear) warm-up step to maximum learning rate and followed by a decaying step to 0 or a minimum learning rate. Currently, there are several methods in literature for the decaying step:\nLinear scheduler Plateau-linear schedule Cosine scheduler Regularization One of the most used regularization method is L2 regularization, aka, weight decay [28]. For instance, GPT 3 training uses a weight decay of 0.1. Note that comparing with traditional neural network tuning weight decay number (such as 0.01) GPT3 weight decay is pretty large.\nLength Extrapolation As in-context learning becomes popular, people are asking a question, Can an LLM maintain equally good, if not better, perplexities when longer sequences are used during inference time? This is the so-called length extrapolation [25].\nOptimizer When we select an optimizer, we have to take consideration of memory footprint and stability issues etc. Options are Adafactor, Adam etc. According to Gopher paper, adafactor optimizer has smaller memory footprint, and on smaller scale model (\u0026lt;7B) adafactor works well. However, when model size goes larger, performance suffers because of stability issue.\nEvaluation A lot of large models come out every year and many claims that they could beat GPT3 model in a wide range of benchmarks like SuperGlue, CLUE, MMLU etc. However, when you do benchmark these models in zero-shot setting or some less common tasks (but still very reasonable ones), these models tend to perform really bad. I personally tested GPT3 model (175b) and UL2 model (20b) on text2sql and sql2text task, GPT3 gives way better performance to the extent that you\u0026rsquo;ll believe UL2 is like garbage. The similar thing happened in evaluation in [24]. You may argue that the model size differs a lot. However, we can think the other way around: the results they claim better than GPT3 is also got from a smaller model and maybe their model training is not easy/efficient to scale to such level. Essentially, what I want to say is that good performance on popular benchmark datasets doesn\u0026rsquo;t mean much for large LM pretraining as this is highly related to source of training data, whether or not doing fine-tuning, proper prompting etc. Human evaluation is what really matters.\nStability During the model training, the most commonly seen issue is gradient exploding, aka, gradient becomes NaN. As layers go deeper, this problem happens more often because the way backpropagation works. Over the years, people have proposed many different ways to solve the challenge. As is shown in paper [21], the post-LN shows stability issue without carefully designed warming-up stage. As a result, they are proposing pre-LN to alleviate the problem.\nThe objective function for highly nonlinear deep neural networks often contains sharp nonlinearities in parameter space resulting from the multiplication of several parameters. These nonlinearities give rise to very high derivatives in some places. When the parameters get close to such a cliff region, a gradient descent update can catapult the parameters very far, possibly losing most of the optimization work that had been done [33].\nIt\u0026rsquo;s important to monitor stability during training. Common practice is to plot activation norm and gradient norm for each step. When these values spike, we know there is something wrong. It\u0026rsquo;s better than looking at loss curve only as loss explosion generally lags behind these two indicators. For instance, when there is bad data, we could have better gauge of when that happens and restart training from that point.\nAdept AI has a lengthy blog post talking about hardware error induced stability issue. The blog mentioned two ways to identify erroneous node(s):\nGrid search: partition nodes into groups and train model on each group in a deterministic way. Find the one that has different training loss curve. Parameter checksum check: for each data parallel run, check parameter checksum to see if they are the same to determine which stage might be wrong. Efficient Inference Inference speed determines product cost. Over the years, people have proposed various ways to improve inference speed. The multiquery attention mentioned above is one of these approaches. References [1] How does GPT Obtain its Ability? Tracing Emergent Abilities of Language Models to their Sources [2] Gopher: Scaling Language Models: Methods, Analysis \u0026amp; Insights from Training Gopher [3] UL2: Unifying Language Learning Paradigms [4] Bloom: Estimating the Carbon Footprint of BLOOM, a 176B Parameter Language Model [5] Scaling Laws for Neural Language Models [6] GPT: Improving Language Understanding by Generative Pre-Training [7] GPT2: Language Models are Unsupervised Multitask Learners [8] GPT3: Language Models are Few-Shot Learners [9] InstructGPT: Training language models to follow instructions with human feedback [10] WebGPT: Browser-assisted question-answering with human feedback [11] OPT: Open Pre-trained Transformer Language Models [12] OPT2: OPT-IML Scaling Language Model Instruction Meta Learning through the Lens of Generalization [13] PaLM: Scaling Language Modeling with Pathways [14] Flan-PaLM: Scaling Instruction-Finetuned Language Models [15] Chinchilla: Training Compute-Optimal Large Language Models [16] Jurassic-1: Technical details and evaluation. [17] Megatron-NLG: Using DeepSpeed and Megatron to Train Megatron-Turing NLG 530B, A Large-Scale Generative Language Model [18] LaMDA: Language Models for Dialog Applications [19] Codex: Evaluating Large Language Models Trained on Code [20] Accurate, Large Minibatch SGD: Training ImageNet in 1 Hour [21] On Layer Normalization in the Transformer Architecture [22] GLM-130B: An Open Bilingual Pre-trained Model [23] T0: Multitask Prompted Training Enables Zero-Shot Task Generalization [24] https://zhuanlan.zhihu.com/p/590240010 [25] RoFormer: Enhanced Transformer with Rotary Position Embedding [26] Receptive Field Alignment Enables Transformer Length Extrapolation [27] On Large-Batch Training for Deep Learning: Generalization Gap and Sharp Minima [28] Decoupled Weight Decay Regularization [29] Do Transformer Modifications Transfer Across Implementations and Applications? [30] xFormers: A modular and hackable Transformer modelling library [31] LLaMA: Open and Efficient Foundation Language Models [32] What Language Model to Train if You Have One Million GPU Hours? [33] On the difficulty of training Recurrent Neural Networks [34] Limits to Depth-Efficiencies of Self-Attention [35] Baichuan LLM [36] Qwen LLM [37] A Pretrainer\u0026rsquo;s Guide to Training Data: Measuring the Effects of Data Age, Domain Coverage, Quality, \u0026amp; Toxicity [38] GLaM: Efficient Scaling of Language Models with Mixture-of-Experts ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/large_scale_pretraining/","summary":"Large language model pretraining is a very challenging task which requires very strong engineering and science skills. People tend to underestimate efforts needed to train a good large model like GPT3 etc. Most people imagine that they can get decent language models given enough computation resources. The fact is even today only OpenAI is providing LM APIs where people can freely play with and get good performances. In this blog, we\u0026rsquo;ll talk about pretraining from the whole pipeline: data sourcing, collection and processing, tokenization, architecture engineering and evaluation. Hopefully, it would be helpful for foundational model training practioners. Data Data is crucial in any ML system. This is true to pretraining as well. As is shown in Gopher paper, a large, diverse and high-quality dataset is needed to train a good model. In the following table, it shows the datasets","title":"Large Scale Pretraining"},{"content":"Basics Kubernetes, also known as “k8s”, is an open source platform solution provided by Google for scheduling and automating the deployment, management, and scaling of containerized applications. Kubernetes has the ability of scheduling and running application containers on a cluster of physical or virtual machines. In managing the applications, the concepts of \u0026rsquo;labels\u0026rsquo; and \u0026lsquo;pods\u0026rsquo; are used to group the containers which make up an application. Currently, it supports Docker for containers.\nkubernetes architecture, image from [1] Pod is a type of abstraction on top of container. Deployment defines the pod. Deployment is used for stateless apps and StatefulSet is used for stateful apps or database. KubeCTL talks with API server to create components or delete components, in other words configuring the cluster. More about this basics is here\nBasic Operations To find out all the pods, using the following command\nkubectl get pods kubectl get pods | grep username kubectl get pods -n my_namespace_name # get pod understand a # get all the nodes kubectl get nodes # get services kubectl get services # create deployment. (blueprint of pod) kubectl create deployment my_pod_name --image=my_image kubectl get deployment To get all the containers running the pod, using the following command\nkubectl get pods my_pod_name -o custom-columns=\u0026#39;NAME:.metadata.name,CONTAINERS:.spec.containers[*].name\u0026#39; kubectl describe pod my_pod_name -n my_namespace_name # To get ip. The ip can be used to launch distributed runs. kubectl get pod my_pod_name --template \u0026#39;{{.status.podIP}}\u0026#39; View logs of job running in the pod\nkubectl logs my_pod_name kubectl logs -f my_pod_name # similar to attach kubectl attach my_pod_name # works with tqdm Log into the pod\nkubectl exec -it my_pod_name -- /bin/bash We can use kubectl to copy files to/from the pod. Be careful that your container may not support ~ this kind of path expansion.\nkubectl cp src_file_path pod:dest_file_path To use rsync is not that straightforward, I\u0026rsquo;m using the tool from here.\n# save the file as krsync, and put it to /usr/bin, and chmod +x to the file #!/bin/bash if [ -z \u0026#34;$KRSYNC_STARTED\u0026#34; ]; then export KRSYNC_STARTED=true exec rsync --blocking-io --rsh \u0026#34;$0\u0026#34; $@ fi # Running as --rsh namespace=\u0026#39;\u0026#39; pod=$1 shift # If use uses pod@namespace rsync passes as: {us} -l pod namespace ... if [ \u0026#34;X$pod\u0026#34; = \u0026#34;X-l\u0026#34; ]; then pod=$1 shift namespace=\u0026#34;-n $1\u0026#34; shift fi exec kubectl $namespace exec -i $pod -- \u0026#34;$@\u0026#34; Then use the following command to sync files. Note that you have to install rsync on the pod.\nkrsync -av --progress --stats src-dir/ pod:/dest-dir # with namespace krsync -av --progress --stats src-dir/ pod@namespace:/dest-dir To make it easier to use, we can add the following to the .zshrc file\nfunction krsync_watch_and_sync_to { fswatch -o . | xargs -n1 -I{} krsync -av --progress --stats *(D) $1 } Sometimes we have to change file ownership. Check out more here\nchown -R 33:33 /data/uploads References [1] Setting up a Kubernetes cluster using Docker in Docker [2] https://kubernetes.io/docs/reference/kubectl/cheatsheet/ ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/kubenetes/","summary":"Basics Kubernetes, also known as “k8s”, is an open source platform solution provided by Google for scheduling and automating the deployment, management, and scaling of containerized applications. Kubernetes has the ability of scheduling and running application containers on a cluster of physical or virtual machines. In managing the applications, the concepts of \u0026rsquo;labels\u0026rsquo; and \u0026lsquo;pods\u0026rsquo; are used to group the containers which make up an application. Currently, it supports Docker for containers. kubernetes architecture, image from [1] Pod is a type of abstraction on top of container. Deployment defines the pod. Deployment is used for stateless apps and StatefulSet is used for stateful apps or database. KubeCTL talks with API server to create components or delete components, in other words configuring the cluster. More about this basics is here Basic Operations To find out all","title":"Kubernetes"},{"content":"Parsing as the very first step of compiling is important for language analysis. ANTLR is a powerful tool to generate parsers. In this blog, we\u0026rsquo;re trying to understand more about ANTLR and its usage.\nANTLR Grammar (1) ANTLR has two kinds of labels: alternative labels and rule elements labels; both can be useful. We assume you are familiar with these two kinds of labels, but here it is an example.\nexpression : left=expression \u0026#39;*\u0026#39; right=expression #multiplication ​ | expression \u0026#39;+\u0026#39; expression #addition ​ | NUMBER #atom ​ ; Alternative labels are the one that follows an #, the rule element labels are the one preceding the = sign. They serve two different purposes. The first ones facilitate act differently for each alternative while the second ones facilitate accessing the different parts of the rules.\nFor alternative labels, if you label one alternative, you have to label all alternatives, because there will be no base node. Rule element labels instead provides an alternative way to access the content parsed by the sub-rule to which the label is assigned.\n(2) For the following grammar, both item nad clause will be parsed as a list in the parsing tree. They can be visited using ctx.items() and ctx.clause()\nexpression : items* ​ | clause+ (3) Parsing nested rule sometimes can be very challenging, the solution is we move the nested on into a new rule, or using labels mentioned above.\nANTLR Lexer (1) In a lexer rule, the characters inside square brackets define a character set. So [\u0026quot;] is the set with the single character \u0026quot;. Being a set, every character is either in the set or not, so defining a character twice, as in [\u0026quot;\u0026quot;] makes no difference, it\u0026rsquo;s the same as [\u0026quot;].\n~ negates the set, so ~[\u0026quot;] means any character except \u0026quot;.\n(2) In lexer or grammar, literals are marked out by quote. In the following example, namedChars will be single-quote quoted char list and ended with X or x\nnamedChars : \u0026#39;\\\u0026#39;\u0026#39; Chars \u0026#39;\\\u0026#39;\u0026#39;[Xx] Note that the grammar doesn\u0026rsquo;t count any spaces in the char.\nANTLR Parser Visitor and Listener Mode ANTLR parser provides two kinds of mechanisms to access the parsing nodes. First is listener mode: we can enter a node to perform actions based on our needs. Second is visitor mode: we can visit all parsing tree nodes top-down, left-right sequentially. This repo provides simple but useful tutorials about how this works.\nReference [1] This blog is very useful for to me when I wrote this summary doc.\n[2] StackOverflow\n[3] The definitive ANTLR Guide book\n","permalink":"https://rich-junwang.github.io/en-us/posts/tech/antlr/","summary":"Parsing as the very first step of compiling is important for language analysis. ANTLR is a powerful tool to generate parsers. In this blog, we\u0026rsquo;re trying to understand more about ANTLR and its usage. ANTLR Grammar (1) ANTLR has two kinds of labels: alternative labels and rule elements labels; both can be useful. We assume you are familiar with these two kinds of labels, but here it is an example. expression : left=expression \u0026#39;*\u0026#39; right=expression #multiplication ​ | expression \u0026#39;+\u0026#39; expression #addition ​ | NUMBER #atom ​ ; Alternative labels are the one that follows an #, the rule element labels are the one preceding the = sign. They serve two different purposes. The first ones facilitate act differently for each alternative while the second ones facilitate accessing the different parts of the rules. For alternative labels, if you label","title":"ANTLR Parser Generator"},{"content":"Diffusion is the process where we gradually convert a know distribution into a target distribution and the corresponding reverse process. Fortunately, people have proved that for gaussian distributions, we can convert data to noise and noise to data using the same functional form.\nFigure 1. diffusion process Forward Process As is shown in the figure above, there are two processes in diffusion:\nForward diffusion process: we slowly and iteratively add noise to the images Reverse diffusion process: we iteratively perform the denoising in small steps starting from a noisy image to convert it back to original form. In the forward process (diffusion process), in each step, gaussian noise is added according to a variance schedule $ \\beta_1, \\dotsb, \\beta_T $ $$ q_\\theta(x_t|x_{t-1}) = \\mathcal{N}(x_t; \\sqrt{(1-\\beta_t)}x_{t-1}, \\beta_t\\mathbf{I}) $$ And it\u0026rsquo;s a Markov chain process, so $$ q_\\theta(x_{1:T}|x_0) = \\prod_{t=1}^{T}q(x_t|x_{t-1}) $$ However, in implementation the above formulation has a problem because doing sequential sampling will result in inefficient forward process. The authors defined the following items: $$ \\alpha_t = 1 - \\beta_t \\\\ \\bar{\\alpha} = \\prod_{s=1}^t\\alpha_s $$ Then we have $$ q_\\theta(x_t|x_0) = \\mathcal{N}(x_t; \\sqrt{\\bar{\\alpha}}x_0, (1 - \\bar{\\alpha_t})\\mathbf{I}) $$\nReparameterization Reparameterization is used on both VAE and diffusion. It\u0026rsquo;s needed because in diffusion, we have a lot of sampling operation and these operations are not differentiable. We use reparameterization to make it differentiable. Concretely, people introduce a random variable $\\epsilon$, then we can sample from any gussian $z \\sim \\mathcal{N}(z; \\mu_{\\theta}, \\sigma^2_{\\theta}\\mathbf{I}) $ as follows: $$ z = \\mu_{\\theta} + \\sigma_{\\theta} \\odot \\epsilon ; \\epsilon \\sim \\mathcal{N}(0, \\mathbf{I}) $$\nReverse Process References [1] Denoising Diffusion Probabilistic Models [2] Understanding Diffusion Models: A Unified Perspective ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/diffusion/","summary":"Diffusion is the process where we gradually convert a know distribution into a target distribution and the corresponding reverse process. Fortunately, people have proved that for gaussian distributions, we can convert data to noise and noise to data using the same functional form. Figure 1. diffusion process Forward Process As is shown in the figure above, there are two processes in diffusion: Forward diffusion process: we slowly and iteratively add noise to the images Reverse diffusion process: we iteratively perform the denoising in small steps starting from a noisy image to convert it back to original form. In the forward process (diffusion process), in each step, gaussian noise is added according to a variance schedule $ \\beta_1, \\dotsb, \\beta_T $ $$ q_\\theta(x_t|x_{t-1}) = \\mathcal{N}(x_t; \\sqrt{(1-\\beta_t)}x_{t-1}, \\beta_t\\mathbf{I}) $$ And it\u0026rsquo;s a Markov chain process, so $$ q_\\theta(x_{1:T}|x_0) = \\prod_{t=1}^{T}q(x_t|x_{t-1}) $$ However,","title":"Diffusion Probabilistic Models"},{"content":"","permalink":"https://rich-junwang.github.io/en-us/posts/blog/blog/","summary":"","title":"Blog"},{"content":"Distributed infrastructure is a big and interesting topic. I don\u0026rsquo;t work on infrastructure side, but I run into the concepts a lot, so I create this blog to help me understand more about infrastructure.\nMost of today\u0026rsquo;s distributed framework involves three parts, collective communication, data loading and preprocessing and distributed scheduler. We\u0026rsquo;ll look into these three parts resepectively.\nCollective Communication We can start with point to point communication. Normally point to point communication refers to two processes communication and it\u0026rsquo;s one to one communication. Accordingly, collective communication refers to 1 to many or many to many communication. In distributed system, there are large amount of communications among the nodes.\nThere are some common communication ops, such as Broadcast, Reduce, Allreduce, Scatter, Gather, Allgather etc.\nBroadcast and Scatter Broadcast is to distribute data from one node to other nodes. Scatter is to distribute a portion of data to different nodes.\nMPI broadcast and scatter Reduce and Allreduce Reduce is a collections of ops. Specifically, the operator will process an array from each process and get reduced number of elements.\nMPI reduce MPI reduce Allreduce means that the reduce operation will be conducted throughout all nodes. An all_reduce takes in a local array on each machine and returns the sum of all the arrays on every machine. Here we show flat all reduce operation below. However, the most common algorithm for doing this is a variant of the “ring allreduce”,\nMPI Allreduce Mixed Precision Training Noramlly, during training we use single precision (32-bit floats). However, for LLM pretraining, this requires high-bandwidth computing platform. To address this challenge, people proposed mixed precision training. As the name suggested, mixed precision training is to leverage mixed different data type during training process, e.g. fp32 and fp16 or fp32 and bf16. We train model mostly in half precisionn and leave some critical ops in fp32. ss\nMixed precision training (image from fastai) Since it has same range as FP32, BF16 mixed precision training skips the scaling steps. All other Mixed Precision steps remain the same as FP16 Mixed Precision. We leave the batchnorm layers in single precision (they don’t have many weights so it’s not a big memory challenge) and compute the loss in single precision (which means converting the last output of the model in single precision before passing it to the loss).","permalink":"https://rich-junwang.github.io/en-us/posts/tech/distributed_training/","summary":"Distributed infrastructure is a big and interesting topic. I don\u0026rsquo;t work on infrastructure side, but I run into the concepts a lot, so I create this blog to help me understand more about infrastructure. Most of today\u0026rsquo;s distributed framework involves three parts, collective communication, data loading and preprocessing and distributed scheduler. We\u0026rsquo;ll look into these three parts resepectively. Collective Communication We can start with point to point communication. Normally point to point communication refers to two processes communication and it\u0026rsquo;s one to one communication. Accordingly, collective communication refers to 1 to many or many to many communication. In distributed system, there are large amount of communications among the nodes. There are some common communication ops, such as Broadcast, Reduce, Allreduce, Scatter, Gather, Allgather etc. Broadcast and Scatter Broadcast is to distribute data from one node to other nodes. Scatter is","title":"Distributed Training Infra"},{"content":"","permalink":"https://rich-junwang.github.io/en-us/posts/life/life/","summary":"","title":"Life"},{"content":"Frequently, I would turn to these quotes as a source of inspiration, using them to encourage personal growth for both my mind and soul.\nPart I The world is your oyster. It\u0026rsquo;s up to you to find the pearls. Still a dreamer, yet more of a realist than ever before, I knew this was my time to sail. On the horizon I saw the shining future, as before. The difference now was that I felt the wind at my back. I was ready. The future was uncertain, absolutely, and there were many hurdles, twists, and turns to come, but as long as I kept moving forward, one foot in front of the other, the voices of fear and shame, the messages from those who wanted me to believe that I wasn\u0026rsquo;t good enough, would be stilled. Others may question your credentials, your papers, your degrees. Others may look for all kinds of ways to diminish your worth. But what is inside you no one can take from you or tarnish. This is your worth, who you really are, your degree that can go with you wherever you go, that you bring with you the moment you come into a room, that can\u0026rsquo;t be manipulated or shaken. Without that sense of self, no amount of paper, no pedigree, and no credentials can make you legit. No matter what, you have to feel legit inside first. Walk that walk and go forward all the time. Don\u0026rsquo;t just talk that talk, walk it and go forward. Also, the walk didn\u0026rsquo;t have to be long strides; baby steps counted too. Go forward. You got a dream\u0026hellip; You gotta protect it. People can\u0026rsquo;t do somethin' themselves, they wanna tell you you can\u0026rsquo;t do it. If you want somethin\u0026rsquo;, go get it. Don\u0026rsquo;t worry if your tasks are small and rewards are few, remember that the mighty oak was once a nut like you. When you know this world as it is and you still love it, then your life will be beautiful. What is a success: To laugh often and much, to win the respect of intelligent people and the affection of children, to earn the appreciation of honest critics and endure the betrayal of false friends, to appreciate beauty, to find the best in others, to leave the world a bit better\u0026hellip; A journey of a thousand miles begins with a single step! Adversity is a catalyst for greatness! Winners worry about winning; losers worry about winners Slow is smooth and smooth is fast Success is not final, failure is not fatal, it is the courage to continue that counts. Part II 不迁怒，不贰过: 回年二十九，发尽白，蚤死。孔子哭之恸，曰：“自吾有回，门人益亲。” 鲁哀公问：“弟子孰为好学？”孔子对曰：“有颜回者好学，不迁怒，不贰过。不幸短命死矣，今也则亡，未闻好学者 也。”\n爱好和付出是一个正反馈的过程\n人生惟有常是第一美德 （曾国藩）\n兄自问近年得力惟一悔字诀。兄昔年自负本领甚大，可屈可伸，可行可藏，又每见得人家不是。自从丁已、戊午大悔大悟之后，乃知自己全无本领，凡事都见得人家有几分是处。故自成午 至今九载，与四十岁以前迥不相同，大约以能立能达为体，以不怨不尤为用。立者，发奋自强，站得住也； 达者，办事圆融，行得通也。（曾国藩）\n孔子曰：君子有九思：视思明，听思聪，色思温，貌思恭，言思忠，事思敬，疑思问，忿思难，见得思义。孔子说：君子有九种考虑：看的时候，考虑看明白了没有；听的时候，考虑听清楚了没有；考虑自己的表情温和么？态度庄重么？说话诚恳老实么？工作严肃认真么？遇到疑难，考虑怎样去 向人家请教；要发怒了，考虑有没有后患；在可以得到利益的时候，考虑是不是该得。\n凡遇牢骚欲发之时，则反躬自思，吾果有何不足，而蓄此不平之气，猛然内省，决然去之。（曾国藩）\n怕什么真理无穷，进一寸有一寸的欢喜.\n他强由他强，清风拂山岗，他横任他横，明月照大江。\n颜渊问仁。子曰：克己复礼，为仁。一日克己复礼，天下归仁焉。为仁由己，而由人乎哉？颜渊曰：请问其目。子曰：非礼勿视，非礼勿听，非礼勿言，非礼勿动。颜渊曰：回虽不敏，请 事斯语矣。\n君子不忧不惧。\n士不可以不弘毅，任重而道远，仁以为己任，不亦重乎，死而后已，不亦远乎。\n为天地立心，为生民立命，为往圣继绝学，为万世开太平。\n修身齐家治国平天下。\n一切众生皆具如来智慧德相，唯以妄想执着不能证得.\n成功不是终结，失败不是终结，唯有勇气才是永恒 (Winston Churchill)\n","permalink":"https://rich-junwang.github.io/en-us/posts/read/quotes/","summary":"Frequently, I would turn to these quotes as a source of inspiration, using them to encourage personal growth for both my mind and soul. Part I The world is your oyster. It\u0026rsquo;s up to you to find the pearls. Still a dreamer, yet more of a realist than ever before, I knew this was my time to sail. On the horizon I saw the shining future, as before. The difference now was that I felt the wind at my back. I was ready. The future was uncertain, absolutely, and there were many hurdles, twists, and turns to come, but as long as I kept moving forward, one foot in front of the other, the voices of fear and shame, the messages from those who wanted me to believe that I wasn\u0026rsquo;t good enough, would be stilled. Others may question your","title":"Quotes"},{"content":"","permalink":"https://rich-junwang.github.io/en-us/posts/read/read/","summary":"","title":"Read"},{"content":"A lot of people are talking about leetcode problem solving these days. If you go to the popular Chinese overseas BBS website, you can find literally under every post there are people talking about solving leetcode problems. In this blog, I want to share my two cents on this issue.\nI personally don\u0026rsquo;t like solving leetcode problems which I guess most people share with my feelings. I don\u0026rsquo;t take any pride in being ranked as the top K problem solver. My opinion is that it\u0026rsquo;s huge waste of time. There are definitely some good parts in doing this. If you\u0026rsquo;re not familiar with a programming langauge, you can learn a bit from good solutions in the disucssion section. Through solving the problem, you\u0026rsquo;ll get familiar with the specific programming language you use. Through the thinking process, you\u0026rsquo;ll learn how to convert logics into codes.\nHowever, focusing on these Fake problems will cost a person gigantic amount of time. There are more important things to learn. In my opinion, a pragmatic engineer should focus on the following four quadrants to improve himself:\nTechnical skills. A good understanding of a wide range of topics such as ML, system design etc. Real problem solving skills. When tasked with a real problem, which is the best route to solve the challenge. Communication skills. How to use concise and precise words to convey your ideas and onboard others with your thoughts. Business acumen. How customers can get benefits from our product, what\u0026rsquo;s our moat, and is our solution going to bring revenue to company. At the end of the day, we want to ask ourselves what kind of innovations/changes we have brought to this world. In my view, that\u0026rsquo;s what defines our value. In the meanwhile, I feel it\u0026rsquo;s a lot more fun in solving the real world problem and tackle the real issues.\nAll big techs today are relying on leetcode to select best talents which, in my opinion, is quite unfortunate.(To be continued)\n\u0026lt;div\u0026gt; 科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码科技代码 科技代码 科技代码 \u0026lt;/div\u0026gt; ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/tech/","summary":"A lot of people are talking about leetcode problem solving these days. If you go to the popular Chinese overseas BBS website, you can find literally under every post there are people talking about solving leetcode problems. In this blog, I want to share my two cents on this issue. I personally don\u0026rsquo;t like solving leetcode problems which I guess most people share with my feelings. I don\u0026rsquo;t take any pride in being ranked as the top K problem solver. My opinion is that it\u0026rsquo;s huge waste of time. There are definitely some good parts in doing this. If you\u0026rsquo;re not familiar with a programming langauge, you can learn a bit from good solutions in the disucssion section. Through solving the problem, you\u0026rsquo;ll get familiar with the specific programming language you use. Through the thinking process, you\u0026rsquo;ll learn how to","title":"Tech \u0026 Talents"},{"content":"LLM Serving Working on LLMs often entails us to conduct a demo for real-time test. Sometimes we have to set things up so that co-worker can play with our model to find out the issues there. An eassy way is to use Flask.\nimport flask app = flask.Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def index(): return \u0026#34;\u0026lt;h3\u0026gt;My LLM Playground\u0026lt;/h3\u0026gt;\u0026#34; Start the Server Start the server, we can run\nApiServicePort=xxxx python3 serve.py Front-End If we use flask render_template to provide the front end, then we can use the following to ways to launch the app,\n# method 1 flask run # method 2 python3 app.py Another way is to use streamlit. Streamlit is an open-source Python library that allows developers to create web applications for data science and machine learning projects with minimal effort. It is designed to simplify the process of turning data scripts into shareable web apps, enabling users to interact with data and models through a web browser. If we use streamlit, we can run with\nstreamlit run app.py Usually we first star the serve and specific the port to listening on. Then pull up the front end page.\nThe page will be like the following, simple and easy!!\nLLM Playground References [1] Openplayground ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/serve_model/","summary":"LLM Serving Working on LLMs often entails us to conduct a demo for real-time test. Sometimes we have to set things up so that co-worker can play with our model to find out the issues there. An eassy way is to use Flask. import flask app = flask.Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def index(): return \u0026#34;\u0026lt;h3\u0026gt;My LLM Playground\u0026lt;/h3\u0026gt;\u0026#34; Start the Server Start the server, we can run ApiServicePort=xxxx python3 serve.py Front-End If we use flask render_template to provide the front end, then we can use the following to ways to launch the app, # method 1 flask run # method 2 python3 app.py Another way is to use streamlit. Streamlit is an open-source Python library that allows developers to create web applications for data science and machine learning projects with minimal effort. It is designed to simplify the process of turning data scripts","title":"LLM Playground"},{"content":"Modern large language model usually is trained with billions number of parameters and trillions number of tokens. With model size and training data at such scale, computation resource and memory footprint requirement is huge. How to effectively leverage GPU resources to speed up training is an important topic in language model pretraining. In this blog, we\u0026rsquo;ll dive deep into parallel training in recent distributed training paradigms.\nA lot of contents of here are from OpenAI, Nvidia, Deepspeed and bigscience blogs. We\u0026rsquo;ll first go through different parallelism techniques and then talk about how to combine them to maximize training efficiency.\nData Parallelism Data parallelism (DP) is the most straightforward way of parallel training. With data parallelism, model parameters and optimzer states are replicated across different workers. Data is partitioned into the same number of shards and each replicate of model is fed with one shard of data. Forward and backward computation is in parallel (simutaneously) and then there is a synchronization step where gradients are averaged across workers to update parameters. The DP computation can be summarized as the following three steps:\nEach machine computes local gradients given local inputs and a consistent global view of the parameters. LocalGrad_i = f(Inputs_i, Targets_i, Params) Sum up all the local gradients and distribute that sum to each machine, so there is a consistent global view of the gradients. GlobalGrad = all_reduce(LocalGrad_i) Each machine can now locally update the parameters and optimizer state under the assumption that the exact same calculation will happen on all machines. NewParams, NewOptimState = g(Params, OldOptimState, GlobalGrad) Pipeline Parallelism Pipeline parallelism (PP) is from model parallelism. Model parallelism is initially proposed to solve that challenge that one model can\u0026rsquo;t fit into one GPU. The idea is we can vertically slice model into different layers (e.g. one or more layers in transformer models) and put different layers in different GPUs. The issue with this method is that because sequential computation order of layers, if we feed single large batch data into one of the workers, all other workers are idle. This is the so-called bubble waiting time.\nTo solve the problem, we can reuse the data parallelism idea. Instead of feeding a single large batch into a model shard, we can partition data into small chunks. Each chunk of data goes through different model shards (workers) in a pipeline way. The following figure illustrates how this works.\nPipeline parallelism. image from [4] Tensor Parallelism The bottleneck of neural network training is compute. Among all the computation parts, the general matrix multiplication (GEMM) consumes the most of time. One way to parallize the matrix multiplication is to use matrix decomposition. Specifically, we can split a matrix into two or multiple parts based on row or column. Then we can aggregate results after the computation of each parts in the end. This is the core idea of tensor parallelism (TP).\nIn it\u0026rsquo;s essence, tensor parallelism is block matrix mutiplication. Based on how we partition the parameter matrix, there is row parallel partition and column parallel partition. For row parallel partition, there is\n$$ Y = XW = \\begin{bmatrix} X_1, \u0026amp; X_2\\end{bmatrix} \\begin{bmatrix} W_1 \\\\ W_2\\end{bmatrix} = X_1W_1 + X_2W_2 $$\nFor column parallel partition, there is $$ Y = XW = X\\begin{bmatrix} W_1 \\\\ W_2\\end{bmatrix} = XW_1 + XW_2 $$ Note that for row parallel, we need to partition the input into two parts as well. In original transformer MLP layer, there are two projection steps: hidden.size -\u0026gt; 4 * hidden.size -\u0026gt; hidden.size. In this case, in Megatron-LM MLP implementation, it first does column parallel partition, generating two matrices, then a row parallel partition. This is shown in the following figure:\nTensor Parallelism in Megatron-LM As these three parallelism is orthogonal to each other, it\u0026rsquo;s easy to combine them together. The following diagram shows how to combine pipeline parallelism with data parallelism.\nCombination of pipeline parallelism and data parallelism. Image from Deepspeed tutorial ZeRO DP Zero Redundancy Optimizer (ZeRO) is an optimizied data parallelism proposed by Deepspeed team. The idea is instead of replicating the whole model, optimizer on each of workers, we can only store needed part.\nZero DP. Image from Deepspeed Parallelism in Megatron Megatron-LM and NeMo are the open source libraries from Nvidia for the distributed training. In these two libs, there are two constraints for the parallelism settings.\n- world_size = TP * PP * DP - global_batch_size % (PP * DP) == 0 Sequence Parallel For operations such as layer normation, the operation can be paralleized on the sequence dimension. Remember that layernorm is normalization over the feature dimenstion, ie. a token representation of 2048 will be normalized over 2048 numbers. In light of this, sequence parallel is proposed to reduce GPU memory consumption.\nSequence parallelism Implementation A few key points in 3D parallelism implementation.\nTP is communication heavy, thus TP blocks should be put on different GPUs within the same node to leverage fast NVLink communication. On the contrary, PP communication is light, and it is usually put across nodes. Within a data parallel group, all GPUs hold the same model parameters. After each update, there will be gradient all-reduce operation. How to achieve this, in Megatron-LM, this is achieved by first partition all GPUs by pipeline parallelism. Then withnin the same pipeline block, partition GPUs based on tensor parallelism. After that, the number of copies within the pipeline block will be the data parallelism number.\nReferences [1] https://huggingface.co/blog/bloom-megatron-deepspeed [2] https://github.com/NVIDIA/NeMo [3] https://openai.com/blog/techniques-for-training-large-neural-networks/ [4] GPipe: Efficient Training of Giant Neural Networks using Pipeline Parallelism [5] Megatron-LM: Training Multi-Billion Parameter Language Models Using Model Parallelism [6] https://www.deepspeed.ai/tutorials/pipeline/\n","permalink":"https://rich-junwang.github.io/en-us/posts/tech/parallelism/","summary":"Modern large language model usually is trained with billions number of parameters and trillions number of tokens. With model size and training data at such scale, computation resource and memory footprint requirement is huge. How to effectively leverage GPU resources to speed up training is an important topic in language model pretraining. In this blog, we\u0026rsquo;ll dive deep into parallel training in recent distributed training paradigms. A lot of contents of here are from OpenAI, Nvidia, Deepspeed and bigscience blogs. We\u0026rsquo;ll first go through different parallelism techniques and then talk about how to combine them to maximize training efficiency. Data Parallelism Data parallelism (DP) is the most straightforward way of parallel training. With data parallelism, model parameters and optimzer states are replicated across different workers. Data is partitioned into the same number of shards and each replicate of model is","title":"Parallelism in LLM Training"},{"content":"Keep SSH Connected There is always one issue that bothers me when using SSH to access server (e.g. EC2) which is that the ssh connection can disconnect very soon. I tried to make changes in the local ssh config: ~/.ssh/config\nHost remotehost HostName remotehost.com ServerAliveInterval 50 Then do a permission change\nchmod 600 ~/.ssh/config However, this doesn\u0026rsquo;t work for me on Mac, and I don\u0026rsquo;t know why. :(\nThen I tried to make changes on server side. In /etc/ssh/sshd_config, add or uncomment the following lines:\nClientAliveInterval 50 ClientAliveCountMax 10 Then restart or reload SSH server to help it recognize the configuration change\nsudo service ssh restart # for ubuntu linux sudo service sshd restart # for other linux dist Finally, log out and try to login again\nlogout This time it works! :)\nAdding SSH Public Key to Server Adding ssh public key to server sometimes can make the connections eaiser. The command is simple:\ncat ~/.ssh/id_ras.pub | ssh -i \u0026#34;my-keypair.pem\u0026#34; ubuntu@myserver \u0026#39;cat \u0026gt;\u0026gt; ~/.ssh/authorized_keys\u0026#39; ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/ssh/","summary":"Keep SSH Connected There is always one issue that bothers me when using SSH to access server (e.g. EC2) which is that the ssh connection can disconnect very soon. I tried to make changes in the local ssh config: ~/.ssh/config Host remotehost HostName remotehost.com ServerAliveInterval 50 Then do a permission change chmod 600 ~/.ssh/config However, this doesn\u0026rsquo;t work for me on Mac, and I don\u0026rsquo;t know why. :( Then I tried to make changes on server side. In /etc/ssh/sshd_config, add or uncomment the following lines: ClientAliveInterval 50 ClientAliveCountMax 10 Then restart or reload SSH server to help it recognize the configuration change sudo service ssh restart # for ubuntu linux sudo service sshd restart # for other linux dist Finally, log out and try to login again logout This time it works! :) Adding SSH Public Key to Server Adding","title":"SSH Connection"},{"content":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找\nscan总共有这几种命令：scan、sscan、hscan、zscan，分别用于迭代数据库中的：数据库中所有键、集合键、哈希键、有序集合键，命令具体结构如下：\nscan cursor [MATCH pattern] [COUNT count] [TYPE type] sscan key cursor [MATCH pattern] [COUNT count] hscan key cursor [MATCH pattern] [COUNT count] zscan key cursor [MATCH pattern] [COUNT count] 2. scan scan cursor [MATCH pattern] [COUNT count] [TYPE type]，cursor表示游标，指查询开始的位置，count默认为10，查询完后会返回下一个开始的游标，当返回0的时候表示所有键查询完了\n127.0.0.1:6379[2]\u0026gt; scan 0 1) \u0026#34;3\u0026#34; 2) 1) \u0026#34;mystring\u0026#34; 2) \u0026#34;myzadd\u0026#34; 3) \u0026#34;myhset\u0026#34; 4) \u0026#34;mylist\u0026#34; 5) \u0026#34;myset2\u0026#34; 6) \u0026#34;myset1\u0026#34; 7) \u0026#34;mystring1\u0026#34; 8) \u0026#34;mystring3\u0026#34; 9) \u0026#34;mystring4\u0026#34; 10) \u0026#34;myset\u0026#34; 127.0.0.1:6379[2]\u0026gt; scan 3 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;myzadd1\u0026#34; 2) \u0026#34;mystring2\u0026#34; 3) \u0026#34;mylist2\u0026#34; 4) \u0026#34;myhset1\u0026#34; 5) \u0026#34;mylist1\u0026#34; MATCH可以采用模糊匹配找出自己想要查找的键，这里的逻辑是先查出20个，再匹配，而不是先匹配再查询，这里加上count 20是因为默认查出的10个数中可能不能包含所有的相关项，所以把范围扩大到查20个，我这里测试的键总共有15个\n127.0.0.1:6379[2]\u0026gt; scan 0 match mylist* count 20 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; TYPE可以根据具体的结构类型来匹配该类型的键\n127.0.0.1:6379[2]\u0026gt; scan 0 count 20 type list 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; 3. sscan sscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是集合类型的key\n127.0.0.1:6379[2]\u0026gt; sadd myset1 a b c d (integer) 4 127.0.0.1:6379[2]\u0026gt; smembers myset1 1) \u0026#34;d\u0026#34; 2) \u0026#34;a\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;b\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;d\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;b\u0026#34; 4) \u0026#34;a\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 match a 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;a\u0026#34; 4. hscan hscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是哈希类型的key\n127.0.0.1:6379[2]\u0026gt; hset myhset1 kk1 vv1 kk2 vv2 kk3 vv3 (integer) 3 127.0.0.1:6379[2]\u0026gt; hgetall myhset1 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 127.0.0.1:6379[2]\u0026gt; hscan myhset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 5. zscan zscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是有序集合类型的key\n127.0.0.1:6379[2]\u0026gt; zadd myzadd1 1 zz1 2 zz2 3 zz3 (integer) 3 127.0.0.1:6379[2]\u0026gt; zrange myzadd1 0 -1 withscores 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; 127.0.0.1:6379[2]\u0026gt; zscan myzadd1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/redis/","summary":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找 scan总共有这几种命令：sca","title":"Redis scan命令学习"},{"content":"About Me\nHi there, this is Jun Wang. Welcome to my website. I'm a programmer. I love programming. Currently, I\u0026rsquo;m a Senior Applied Scientist at Amazon. My research focuses on LLMs, foundational model training, machine learning and its applications in natural language processing. I aim to design systems that understand natural language in a way that makes sense to humans. Generally, I’m interested in areas such as semantic parsing, question answering and knowledge representation learning and reasoning, language grounding, and methods insipred by cognitive science.\nOpinions are my own and I do not speak for my employer or my team. On this webpage, I'd like to share my study and my paper reading. Feel free to reach out to me if you have any comments/suggestions\nIn my spare time, I like hiking a lot. I'm also very much into reading books of history, biography etc. Drop me a line if you want to chat more! Publications\nAll my publications can be found on google scholar Professional Services\nReviewer for NeurIPS, ICLR 2023 Reviewer for AMLC 2020, 2021 Reviewer for ICLR 2022 Reviewer for AAAI 2021 ","permalink":"https://rich-junwang.github.io/en-us/about/","summary":"About Me Hi there, this is Jun Wang. Welcome to my website. I'm a programmer. I love programming. Currently, I\u0026rsquo;m a Senior Applied Scientist at Amazon. My research focuses on LLMs, foundational model training, machine learning and its applications in natural language processing. I aim to design systems that understand natural language in a way that makes sense to humans. Generally, I’m interested in areas such as semantic parsing, question answering and knowledge representation learning and reasoning, language grounding, and methods insipred by cognitive science. Opinions are my own and I do not speak for my employer or my team. On this webpage, I'd like to share my study and my paper reading. Feel free to reach out to me if you have any comments/suggestions In my spare time, I like hiking a lot. I'm also very much","title":"🙋🏻‍♂️About"},{"content":"Add the following into extend_head.html\n{{ if or .Params.math .Site.Params.math }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body, // The following is to parse inline math equation { delimiters: [ {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false} ] } );\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} Then in the markdown file, in the header section we add math: true.\nMethods to Show Math The the above setup, you can use the following ways in the markdown writeup.\n\\\\(E=mc^2\\\\) $$E=mc^2$$ $E=mc^2$ ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/add_math/","summary":"Add the following into extend_head.html {{ if or .Params.math .Site.Params.math }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body, // The following is to parse inline math equation { delimiters: [ {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false} ] } );\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} Then in the markdown file, in the header section we add math: true. Methods to Show Math The the above setup, you can use the following ways in the markdown writeup. \\\\(E=mc^2\\\\) $$E=mc^2$$ $E=mc^2$","title":"Add Math Equation in Blog"},{"content":"In the last blog, we talked about commonly used AWS commands. In this blog, I\u0026rsquo;ll document some commonly used docker commands to save some time when I need them.\nImage docker image ls # pull an image docker pull iamge_name Run docker container # rm is to clean constainer after exit # it is interactive tty # for normal docker image docker run --entrypoint /bin/bash -it \u0026lt;image_name\u0026gt; # for nvidia docker image nvidia-docker run --entrypoint /bin/bash --rm -it --name my_container_name image_name # mount a volume to docker # --rm delete docker on exit nvidia-docker run --entrypoint /bin/bash -v $PWD/transforms_cache:/transforms_cache --rm -it image_name # add env to docker system nvidia-docker run --entrypoint /bin/bash -v $PWD/transforms_cache:/transforms_cache --rm --env SM_CHANNEL_TRAIN=/opt/ml/input/data/train -it image_name # docker run to use GPU, we can use another command docker run --entrypoint /bin/bash --gpus all -it xxxx_image_name Check all containers docker ps -a Clean space docker rmi -f $(docker images -a -q) sudo docker system prune Install package Install packages inside a running docker. Usually we\u0026rsquo;re able to install package based on distributeion of linux system running in the docker. For example, if it\u0026rsquo;s ubuntu, then the command is\napt-get -y update apt-get -y install tmux # package name Docker build We can use the following command to build docker image. Notice that the path is . (current directory). The path (a set of files) is called context and files inside can be used in COPY command in dockerfile. In building process, context will be packed into a tar file. So it\u0026rsquo;s good to put unnecessary files into .dockerignore file and select a reasonable path as context.\ndocker build -f Dockerfile_my_docker -t ${TAG} . --build-arg REGION=${region} ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/docker-commands/","summary":"In the last blog, we talked about commonly used AWS commands. In this blog, I\u0026rsquo;ll document some commonly used docker commands to save some time when I need them. Image docker image ls # pull an image docker pull iamge_name Run docker container # rm is to clean constainer after exit # it is interactive tty # for normal docker image docker run --entrypoint /bin/bash -it \u0026lt;image_name\u0026gt; # for nvidia docker image nvidia-docker run --entrypoint /bin/bash --rm -it --name my_container_name image_name # mount a volume to docker # --rm delete docker on exit nvidia-docker run --entrypoint /bin/bash -v $PWD/transforms_cache:/transforms_cache --rm -it image_name # add env to docker system nvidia-docker run --entrypoint /bin/bash -v $PWD/transforms_cache:/transforms_cache --rm --env SM_CHANNEL_TRAIN=/opt/ml/input/data/train -it image_name # docker run to use GPU, we can use another command docker run --entrypoint /bin/bash --gpus all -it xxxx_image_name Check all","title":"Docker Commands"},{"content":"Bayesian Method Maximium likelihood estimation assumes that there is one distribution with a fix set of parameters which describes data samples, i.e. all data are sampled from this specific distribution. On the other hand, Bayesian method thinks that there could be multiple distrbutions that can describe the data. We choose one set of parameters which parameterize one distribution based on observations to describe the data. The distribution we choose is shaped by the prior we use.\nEM Algorithm ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/probability/","summary":"Bayesian Method Maximium likelihood estimation assumes that there is one distribution with a fix set of parameters which describes data samples, i.e. all data are sampled from this specific distribution. On the other hand, Bayesian method thinks that there could be multiple distrbutions that can describe the data. We choose one set of parameters which parameterize one distribution based on observations to describe the data. The distribution we choose is shaped by the prior we use. EM Algorithm","title":"EM Algorithm"},{"content":"LayerNorm vs BatchNorm BatchNorm is commonly used in computer vision. LayerNorm is widely used in NLP. In CV, the channel dimension is RGB channel. In NLP, the channel dimension is feature dimin (embedding dim). Layer norm normalizes across feature dimension (such as embedding dim) for each of the inputs which removes the dependence on batches. This makes layer normalization well suited for sequence models such as transformers.\nFigure 1. batch norm vs layer norm After understanding of the basics, we can write down the pseudo code as below Pseudo code for batch norm\nfor i in range(seq_len): for j in range(hidden_size): Norm([bert_tensor[k][i][j] for k in range(batch_size)]) Pseudo code for layer norm\nfor i in range(batch_size): for j in range(seq_len): Norm([bert_tensor[i][j][k] for k in range(hidden_size)]) PyTorch implementation is shown blow. When using for BatchNorm, dim=0, assuming x is of the shape (batch_size, H, W, channel). When using for LayerNorm, dim=-1, assuming x is of shape (batch_size, seq_len, embed_dim).\nclass Norm(nn.Module): def __init__(self, num_features, variance_epsilon=1e-12): super(Norm, self).__init__() self.gamma = nn.Parameter(torch.ones(num_features)) self.beta = nn.Parameter(torch.zeros(num_features)) self.variance_epsilon = variance_epsilon def forward(self, x, dim): # layer norm, x is [bz, seq_len, dim], u is [bz, seq_len, 1], x_norm is the same shape with u u = x.mean(dim, keepdim=True) s = (x - u).pow(2).mean(dim, keepdim=True) x_norm = (x - u) / torch.sqrt(s + self.variance_epsilon) return self.gamma * x_norm + self.beta EMA in BN Note that at inference time, there could be no batch dimension for batch norm. In practice, during training people will keep record of moving average of mean and variance. During inference time, these values will be used. The exponential moving average is calculated as follows\nmoving_mean = moving_mean * momentum + batch_mean * (1 - momentum) moving_var = moving_var * momentum + batch_var * (1 - momentum) The momentum is a hyperparameter which is generally chosen to be close to 1. A lower value of momentum means that older values are forgotten sooner. A more efficient way to calculate it is as follows:\nmoving_mean -= (moving_mean - batch_mean) * (1 - momentum) moving_var -= (moving_var - batch_var) * (1 - momentum) ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/transformer/","summary":"LayerNorm vs BatchNorm BatchNorm is commonly used in computer vision. LayerNorm is widely used in NLP. In CV, the channel dimension is RGB channel. In NLP, the channel dimension is feature dimin (embedding dim). Layer norm normalizes across feature dimension (such as embedding dim) for each of the inputs which removes the dependence on batches. This makes layer normalization well suited for sequence models such as transformers. Figure 1. batch norm vs layer norm After understanding of the basics, we can write down the pseudo code as below Pseudo code for batch norm for i in range(seq_len): for j in range(hidden_size): Norm([bert_tensor[k][i][j] for k in range(batch_size)]) Pseudo code for layer norm for i in range(batch_size): for j in range(seq_len): Norm([bert_tensor[i][j][k] for k in range(hidden_size)]) PyTorch implementation is shown blow. When using for BatchNorm, dim=0, assuming x is of the shape","title":"Transformer"},{"content":"Using PyTorch for NN model training on single GPU is simple and easy. However, when it comes to multiple GPU training, there could be various of issues. In this blog, I\u0026rsquo;ll summarize all kinds of issues I ran into during model training/evaluation.\nLoading a pretrained checkpoint A lot of times when we save a checkpoint of a pretrained model, we also save the trainer (or model state) information. This means when we load model checkpoint again, model will already have a preallocated device. When we use the same number of GPU to continue training, it will work as expected. However, the issue will arise when we have different number of GPUs for two runs. Let\u0026rsquo;s say, we first trained model on a single GPU, then we want to use multiple GPU to continue the training. When we move model to multiple GPU, there will be something weird. For instance, on GPU 0, you might see multiple process (normally one process per GPU). Or in other cases, you can see GPU 0 has much higher memory usage than other GPUs.\nSolution: when we load model, we only load parameters and strip all state information. This might be tricky sometimes. The simplest way to solve this issue is to wrap the command with with PyTorch distributed data parallel.\npython3 -m torch.distributed.launch --nnodes=1 --nproc_per_node=8 my_script.py my_config_file Install Apex Sometimes to use the latest distributed training feature, we have to install Apex. As Apex is closely coupled with Cuda, we need to follow the next few steps to correctlly install apex.\nFind out the Cuda version used in the system. python -c \u0026#34;import torch; print(torch.version.cuda)\u0026#34; Install from source git clone https://github.com/NVIDIA/apex cd apex CUDA_HOME=/usr/local/cuda-{your-version-here}/ pip install -v --disable-pip-version-check --no-cache-dir --global-option=\u0026#34;--cpp_ext\u0026#34; --global-option=\u0026#34;--cuda_ext\u0026#34; ./ Commonly Used Pytorch Tricks Distributed training is error-prone, so effective ways of debugging is needed. Here I document some of these commands\n# print the whole tensor torch.set_printoptions(profile=\u0026#34;full\u0026#34;) torch.set_printoptions(linewidth=16000) Dataloader sometimes can be buggy, when there are errors related to dataloader, a good practice is to disable the worker number and disable prefetching.\nLaunch Distributed Run python3 -m torch.distributed.run --nnodes=2 --nproc_per_node 8 --node_rank=${NODE_RANK} --master_port=1234 --master_addr=xxx train.py args.. Pytorch and Numpy Advanced Indexing When selection object is sequence object, ndarray/tensor, it will trigger advanced indexing. To understand how it works, we start from simple.\nx = np.arange(12).reshape(4,3) print(x) #output [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] (1) Specify integer arrays in each dimension where every element in the array represents a number of indices into that dimension. In the example below, we select (0, 0), (1, 1), (2, 0) elements from the above array. x has two dimensions so we have two arrays to specify the indices in each dimension.\ny = x[[0,1,2], [0,1,0]] print(y) #[0 4 6] (2) The above way of indexing only renders single dimension result. We can use multi-dimension array to get multi-dimension output. Below is one of these examples. This is to select [(0, 0), (0, 2)], [(3, 0), (3, 2)] elements. Note that in each dimension we still only select one index, like 0 from row-dim, and 0 from col-dim.\nrows = np.array([[0,0],[3,3]]) cols = np.array([[0,2],[0,2]]) y = x[rows,cols] print (y) # output [[ 0 2] [ 9 11]] ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/pytorch/","summary":"Using PyTorch for NN model training on single GPU is simple and easy. However, when it comes to multiple GPU training, there could be various of issues. In this blog, I\u0026rsquo;ll summarize all kinds of issues I ran into during model training/evaluation. Loading a pretrained checkpoint A lot of times when we save a checkpoint of a pretrained model, we also save the trainer (or model state) information. This means when we load model checkpoint again, model will already have a preallocated device. When we use the same number of GPU to continue training, it will work as expected. However, the issue will arise when we have different number of GPUs for two runs. Let\u0026rsquo;s say, we first trained model on a single GPU, then we want to use multiple GPU to continue the training. When we move model to","title":"Pytorch Multiple-GPU Training"},{"content":"RL Basics There are two fundamental problems in the sequential decision making process: reinforcement learning and planning. In reinforcement learning, the environment is unknown and agent interacts with environment to improve its policy. Within reinforcement learning there are two kinds of operation: prediction and control. Prediction is given policy, evaluate the future. Control is to optimize the future to find the optimal policy. In RL, we alternatively do predition and control to get the best policy.\nIn terms of methods, RL algorithm can be categorized into two types: model-free algorithm and model-based algorithm. In model-free algorithms, we don\u0026rsquo;t want to or we can\u0026rsquo;t learn the system dynamics. We sample actions and get corresponding rewards to optimize policy or fit a value function. It can further be divied into two methods: policy optimization or value learning.\nPlanning Value Iteration: Value iteration uses dynamic programming to compute the value function iteratively using Bellman equation. Policy iteration — Compute the value function and optimize the policy in alternative steps RL Value-learning/Q-learning: Without an explicit policy, we fit the value-function or Q-value function iteratively with observed rewards under actions taken by an off-policy, like an ε-greedy policy which selects action based on the Q-value function and sometimes random actions for exploration. Policy gradients: using neural network to approximate policy and optimize policy using gradient ascent. References [1] RL — Reinforcement Learning Algorithms Overview\n","permalink":"https://rich-junwang.github.io/en-us/posts/tech/rl/","summary":"RL Basics There are two fundamental problems in the sequential decision making process: reinforcement learning and planning. In reinforcement learning, the environment is unknown and agent interacts with environment to improve its policy. Within reinforcement learning there are two kinds of operation: prediction and control. Prediction is given policy, evaluate the future. Control is to optimize the future to find the optimal policy. In RL, we alternatively do predition and control to get the best policy. In terms of methods, RL algorithm can be categorized into two types: model-free algorithm and model-based algorithm. In model-free algorithms, we don\u0026rsquo;t want to or we can\u0026rsquo;t learn the system dynamics. We sample actions and get corresponding rewards to optimize policy or fit a value function. It can further be divied into two methods: policy optimization or value learning. Planning Value Iteration: Value iteration","title":"RL Basics"},{"content":"Remote Development I used to do development on my local machine, and use fswatch and rsync to sync changes to server in real time. It works perfectly when development dependencies are simple and easy to set up. Generally I refer this development mode as local development. However, as more and more development environments are containerized, it becomes non-trivial to set up environment everytime. Recently, I started using VSCode as it has better support to leverage remote server development environment.\nOne great feature of VScode is that it works well with docker and kubernetes, i.e. we can attach VSCode to docker or kubernetes pods easily. In vscode terminal, we can execute commands like we\u0026rsquo;re doing on the server. I call this kind of development as remote development.\nOne problem with remote development is that we can\u0026rsquo;t save our changes locally. Once server dies, all our changes are gone. The solution is to use git. Since docker doesn\u0026rsquo;t come with an editor, when we use git, we have to set vscode as the editor:\ngit config --global core.editor \u0026#34;code --wait\u0026#34; Another issue is we have to install extensions on remote server. For instance, we have to install python extension in order to use python interpreter in remote mode.\nVScode also has a nice extension tool to sync code to remote server.\nVScode Shortcuts If it\u0026rsquo;s on Mac, replace CTRL key with CMD key\n(1) CTRL + X : cut a line (2) duplicate a line: duplicate can be achieved by CTRL+C and CTRL+V with cursor in the line (without selection)\n(3) edit multiple line\nedit multiple line simultaneously: CTRL + SHIFT + up/down arrow. (This will be continuous) ALT + CLICK: can select multiple place and edit CTRL + SHIFT + L: edit all variable in the file (4) block comment: select the block, then CTRL + SHIFT + A\n(5) line comment: CTRL + /\n(6) search \u0026amp; replace\nsingle file search: CTRL + F single file replace: CTRL + H global search: CTRL + SHIFT + F global replace: CTRL + SHIFT + H (7) move a line upward or downward: ALT + up/down arrow\n(8) select a line: CTRL + L\n(9) palette\nopen palette: CTRL + P \u0026gt;: type command @: find symbol #: find all relevant ones : go to line (10) split screen vertical split: CTRL + \\\n(11) open a new window for a new project CTRL + SHIFT + N\n(12) Open terminal CTRL + ` to toggle terminal panel. Note one mac here it\u0026rsquo;s CTRL as well.\n(13) Close search window after global search In keybindings.json add the following lines\n{ \u0026#34;key\u0026#34;: \u0026#34;Escape\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;workbench.view.explorer\u0026#34;, \u0026#34;when\u0026#34;: \u0026#34;searchViewletVisible\u0026#34; } (14) How to open unlimited number of tabs In settings.json add the following key-value pair:\n\u0026#34;workbench.editor.enablePreview\u0026#34;: false Config Here is the config settings I used.\n{ \u0026#34;editor.fontSize\u0026#34;: 16, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;editor.wordWrap\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;editor.tabCompletion\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;editor.tabSize\u0026#34;: 4, \u0026#34;editor.suggest.snippetsPreventQuickSuggestions\u0026#34;: false, \u0026#34;gitlens.codeLens.authors.enabled\u0026#34;: false, \u0026#34;git.timeline.showAuthor\u0026#34;: false, \u0026#34;gitlens.codeLens.recentChange.enabled\u0026#34;: false, \u0026#34;gitlens.codeLens.enabled\u0026#34;: false, \u0026#34;gitlens.currentLine.enabled\u0026#34;: false, \u0026#34;gitlens.currentLine.pullRequests.enabled\u0026#34;: false, \u0026#34;redhat.telemetry.enabled\u0026#34;: false, \u0026#34;terminal.integrated.fontSize\u0026#34;: 16, \u0026#34;editor.minimap.enabled\u0026#34;: false, \u0026#34;python.terminal.activateEnvironment\u0026#34;: false, \u0026#34;workbench.editor.enablePreview\u0026#34;: false, \u0026#34;[python]\u0026#34;: { \u0026#34;editor.formatOnType\u0026#34;: true }, \u0026#34;settingsSync.ignoredSettings\u0026#34;: [], \u0026#34;settingsSync.ignoredExtensions\u0026#34;: [], //失去焦点后自动保存 \u0026#34;files.autoSave\u0026#34;: \u0026#34;onFocusChange\u0026#34;, \u0026#34;terminal.integrated.inheritEnv\u0026#34;: false, } References [1] https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf\n","permalink":"https://rich-junwang.github.io/en-us/posts/tech/programming_language/remote-development-with-vscode/","summary":"Remote Development I used to do development on my local machine, and use fswatch and rsync to sync changes to server in real time. It works perfectly when development dependencies are simple and easy to set up. Generally I refer this development mode as local development. However, as more and more development environments are containerized, it becomes non-trivial to set up environment everytime. Recently, I started using VSCode as it has better support to leverage remote server development environment. One great feature of VScode is that it works well with docker and kubernetes, i.e. we can attach VSCode to docker or kubernetes pods easily. In vscode terminal, we can execute commands like we\u0026rsquo;re doing on the server. I call this kind of development as remote development. One problem with remote development is that we can\u0026rsquo;t save our changes locally. Once","title":"Remote Development with VSCode"},{"content":"Sigmoid Sigmoid is one of the most used activation functions. $$ \\sigma(x) = \\frac{1}{1+e^{-x}} $$ It has nice mathematical proprities: $$ \\sigma^\\prime(x) = \\sigma(x) \\left[ 1 - \\sigma(x) \\right] $$ and $$ \\left[log\\sigma(x)\\right]^\\prime = 1 - \\sigma(x) \\\\ \\left[log\\left(1 - \\sigma(x)\\right)\\right]^\\prime = - \\sigma(x) $$\nLogistic Regression For a binary classification problem, for an example $x = (x_1, x_2, \\dotsb , x_n)^T$, the hypothesis function (for the positive class) can be written as: $$ \\begin{aligned} h_{\\theta}(1|x) \u0026amp;= \\sigma(\\theta_0 + \\theta_1x_1 + \\theta_2x_2 + \\dotsb + \\theta_nx_n) \\\\ \u0026amp;= \\sigma(\\theta^{\\mathrm{T}}x) \\\\ \u0026amp;= \\frac{1}{1+e^{-\\theta^{\\mathrm{T}}x}} \\end{aligned} $$ Consequently, for the negative class, $$ \\begin{aligned} h_{\\theta}(0|x) \u0026amp;= 1 - \\frac{1}{1+e^{-\\theta^{\\mathrm{T}}x}} \\\\ \u0026amp;= \\frac{1}{1+e^{\\theta^{\\mathrm{T}}x}} \\\\ \u0026amp;= \\sigma(-\\theta^{\\mathrm{T}}x) \\end{aligned} $$\nSingle sample cost function of logistic regression is expressed as: $$ L(\\theta) = -y_i \\cdot \\log(h_\\theta(x_i)) - (1-y_i) \\cdot \\log(1 - h_\\theta(x_i)) $$ Notice that in the second term $1 - h_\\theta(x_i)$ is the negative class probability\nCross Entropy Cross entropy defines the distance between model output distribution and the groudtruth distribution. $$ H(y,p) = -\\sum_{i}y_i \\log(p_i) $$ Since the $y_i$ is the class label (1 for positive class, 0 for negative), essentially here we\u0026rsquo;re summing up the negative log probably of the positive label. What is the reason why we say that negative log likehood and cross entropy is equivalent.\nWhen normalization function (we can say activation function of last layer) is softmax function, namely, for each class $s_i$ the probability is given by $$ f(s)_i = \\frac{e^{s_i}}{ \\sum_j ^{C} e^{s_j}} $$ Given the above cross entropy equation, and there is only one positive class, the softmax cross entropy loss is: $$ L = -log(\\frac{e^{s_p}}{ \\sum_j ^{C} e^{s_j}}) $$ here $p$ stands for positive class. If we want to get the gradient of loss with respect to the logits ($s_i$ here), for positive class we can have $$ \\frac{\\partial{L}}{\\partial{s_p}} = \\left(\\frac{e^{s_p}}{ \\sum_j ^{C} e^{s_j}} - 1 \\right) \\\\ \\frac{\\partial{L}}{\\partial{s_n}} = \\left(\\frac{e^{s_n}}{ \\sum_j ^{C} e^{s_j}} - 1 \\right) $$ We can put this in one equation, which is what we commonly see as the graident of cross entropy loss for softmax $$ \\frac{\\partial{L}}{\\partial{s_i}} = p_i - y_i $$ $p_i$ is the probability and $y_i$ is the label, 1 for positive class and 0 for negative class.\nBinary Cross Entropy In the above section, we talked about softmax cross entropy loss, here we talk about binary cross entropy loss which is also called Sigmoid cross entropy loss.\nWe apply sigmoid function to the output logits before BCE. Notice that here we apply the function to each element in the tensor, all the elements are not related to each other, this is why BCE is widely used for multi-label classification task.\nFor each label, we can calculate the loss in the same way as the logistic regression loss.\nimport torch import numpy as np pred = np.array([[-0.4089, -1.2471, 0.5907], [-0.4897, -0.8267, -0.7349], [0.5241, -0.1246, -0.4751]]) # after sigmod, pred becomes # [[0.3992, 0.2232, 0.6435], # [0.3800, 0,3044, 0.3241], # [0.6281, 0.4689, 0.3834]] label = np.array([[0, 1, 1], [0, 0, 1], [1, 0, 1]]) # after cross entropy, pred becomes # [[-0.5095, -1.4997, -0.4408], take neg and avg 0.8167 # [-0.4780, -0.3630, -1.1267], take neg and avg 0.6559 # [-0.4651, -0.6328, -0.9587]] take neg and avg 0.6855 # 0 * ln0.3992 + (1-0) * ln(1-0.3992) = -0.5095 # (0.8167 + 0.6559 + 0.6855) / 3. = 0.7194 pred = torch.from_numpy(pred).float() label = torch.from_numpy(label).float() crition1 = torch.nn.BCEWithLogitsLoss() loss1 = crition1(pred, label) print(loss1) # 0.7193 crition2 = torch.nn.MultiLabelSoftMarginLoss() loss2 = crition2(pred, label) print(loss2) # 0.7193 Noise Contrastive Estimation Noise contrastive estimation or negative sampling is a commonly used computation trick in ML to deal with expansive softmax computation or intractable partition function in computation.\nThe derivation of NCE loss sometimes can be bewildering, but the idea is actually very simple. For example, in word2vec implementation, the negative sampling is to choose 1 positive target and 5 negative target, and calculate the binary cross entropy loss (binary logistic loss) and then do backward propagation.\nContrastive Loss CLIP Loss CLIP loss is the same with the paper from [3]. The negatives here are used for contrastive learning. However, they\u0026rsquo;re not using NCE method like word2vec. It\u0026rsquo;s more like softmax cross entropy.\nimport torch from torch import nn import torch.nn.functional as F import config as CFG from modules import ImageEncoder, TextEncoder, ProjectionHead class CLIPModel(nn.Module): def __init__( self, temperature=CFG.temperature, image_embedding=CFG.image_embedding, text_embedding=CFG.text_embedding, ): super().__init__() self.image_encoder = ImageEncoder() self.text_encoder = TextEncoder() self.image_projection = ProjectionHead(embedding_dim=image_embedding) self.text_projection = ProjectionHead(embedding_dim=text_embedding) self.temperature = temperature def forward(self, batch): # Getting Image and Text Features image_features = self.image_encoder(batch[\u0026#34;image\u0026#34;]) text_features = self.text_encoder( input_ids=batch[\u0026#34;input_ids\u0026#34;], attention_mask=batch[\u0026#34;attention_mask\u0026#34;] ) # Getting Image and Text Embeddings (with same dimension) image_embeddings = self.image_projection(image_features) text_embeddings = self.text_projection(text_features) # Calculating the Loss logits = (text_embeddings @ image_embeddings.T) / self.temperature images_similarity = image_embeddings @ image_embeddings.T texts_similarity = text_embeddings @ text_embeddings.T targets = F.softmax( (images_similarity + texts_similarity) / 2 * self.temperature, dim=-1 ) texts_loss = cross_entropy(logits, targets, reduction=\u0026#39;none\u0026#39;) images_loss = cross_entropy(logits.T, targets.T, reduction=\u0026#39;none\u0026#39;) loss = (images_loss + texts_loss) / 2.0 # shape: (batch_size) return loss.mean() def cross_entropy(preds, targets, reduction=\u0026#39;none\u0026#39;): log_softmax = nn.LogSoftmax(dim=-1) loss = (-targets * log_softmax(preds)).sum(1) if reduction == \u0026#34;none\u0026#34;: return loss elif reduction == \u0026#34;mean\u0026#34;: return loss.mean() if __name__ == \u0026#39;__main__\u0026#39;: images = torch.randn(8, 3, 224, 224) input_ids = torch.randint(5, 300, size=(8, 25)) attention_mask = torch.ones(8, 25) batch = { \u0026#39;image\u0026#39;: images, \u0026#39;input_ids\u0026#39;: input_ids, \u0026#39;attention_mask\u0026#39;: attention_mask } CLIP = CLIPModel() loss = CLIP(batch) print(\u0026#34;\u0026#34;) Reference Learning Transferable Visual Models From Natural Language Supervision http://www.cnblogs.com/peghoty/p/3857839.html contrastive learning of medical visual representations from paired images and text https://github.com/moein-shariatnia/OpenAI-CLIP/blob/master/CLIP.py ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/loss/","summary":"Sigmoid Sigmoid is one of the most used activation functions. $$ \\sigma(x) = \\frac{1}{1+e^{-x}} $$ It has nice mathematical proprities: $$ \\sigma^\\prime(x) = \\sigma(x) \\left[ 1 - \\sigma(x) \\right] $$ and $$ \\left[log\\sigma(x)\\right]^\\prime = 1 - \\sigma(x) \\\\ \\left[log\\left(1 - \\sigma(x)\\right)\\right]^\\prime = - \\sigma(x) $$ Logistic Regression For a binary classification problem, for an example $x = (x_1, x_2, \\dotsb , x_n)^T$, the hypothesis function (for the positive class) can be written as: $$ \\begin{aligned} h_{\\theta}(1|x) \u0026amp;= \\sigma(\\theta_0 + \\theta_1x_1 + \\theta_2x_2 + \\dotsb + \\theta_nx_n) \\\\ \u0026amp;= \\sigma(\\theta^{\\mathrm{T}}x) \\\\ \u0026amp;= \\frac{1}{1+e^{-\\theta^{\\mathrm{T}}x}} \\end{aligned} $$ Consequently, for the negative class, $$ \\begin{aligned} h_{\\theta}(0|x) \u0026amp;= 1 - \\frac{1}{1+e^{-\\theta^{\\mathrm{T}}x}} \\\\ \u0026amp;= \\frac{1}{1+e^{\\theta^{\\mathrm{T}}x}} \\\\ \u0026amp;= \\sigma(-\\theta^{\\mathrm{T}}x) \\end{aligned} $$ Single sample cost function of logistic regression is expressed as: $$ L(\\theta) = -y_i \\cdot \\log(h_\\theta(x_i)) - (1-y_i) \\cdot \\log(1 - h_\\theta(x_i)) $$ Notice that in","title":"Loss in ML"},{"content":"Git Git merge Suppose we\u0026rsquo;re on master branch, if we want to override the changes in the master branch with feature branch, we can use the following command\ngit merge -X theirs feature to keep the master branch changes:\ngit merge -X ours feature If we want to rebase of current branch onto the master, and want to keep feature branch\ngit rebase master -X theirs if we want to keep master branch changes over our feature branch, the\ngit rebase master -X ours To summarize, we can have the following table:\n\u0026nbsp; Currently on Command \u0026nbsp; \u0026nbsp; Strategy \u0026nbsp; \u0026nbsp; Outcome \u0026nbsp;master git merge feature \u0026nbsp; -Xtheirs \u0026nbsp; \u0026nbsp; Keep changes from feature branch master git merge feature -Xours keep changes from master branch \u0026nbsp;feature git rebase master \u0026nbsp; -Xtheirs \u0026nbsp; \u0026nbsp; Keep changes from feature branch feature git rebase master -Xours keep changes from master branch {:.mbtablestyle} #### Git Diff To check two branch difference, suppose we\u0026rsquo;re on branch1, then we can do,\ngit diff HEAD..master Delete a remote branch Delete a remote branch\ngit push origin -d remote_branch_name Git rebase To fixup, squash, edit, drop, reword and many other operations on the previous N commit:\ngit rebase -i HAED~N Git commit git commit --amend --no-edit Undo git add The simplest way to undo a git add is to use git reset. It removes staged file, but will keeop the local changes there.\ngit reset file_path Git check difference Use the following command to checkout COMMIT (commit hash) ancestor and COMMIT difference\ngit diff COMMIT~ COMMIT git diff HEAD~ HEAD Git rebase resolve conflicts Sometimes when we do git rebase and we have many commits, we have to resolve a lot of conflicts, which can be really frustrating. One quick way might be to squash commits first to have a single commit, then do rebase. Another way is what we describe below.\nFirst, checkout temp branch from feature branch and start a standard merge\ngit checkout -b temp git merge origin/master git commit -m \u0026#34;Merge branch \u0026#39;origin/master\u0026#39; into \u0026#39;temp\u0026#39;\u0026#34; You will have to resolve conflicts, but only once and only real ones. Then stage all files and finish merge. Then return to your feature branch and start rebase, but with automatically resolving any conflicts.\ngit checkout feature git rebase origin/master -X theirs Branch has been rebased, but project is probably in invalid state. We just need to restore project state, so it will be exact as on branch \u0026rsquo;temp\u0026rsquo;. Technically we just need to copy its tree (folder state) via low-level command git commit-tree. Plus merging into current branch just created commit.\ngit merge --ff $(git commit-tree temp^{tree} -m \u0026#34;Fix after rebase\u0026#34; -p HEAD) git branch -D temp More details is here: https://github.com/capslocky/git-rebase-via-merge. Thanks to the original author!\nFind Command The original post is here: https://www.baeldung.com/linux/find-exec-command\n1. Basics The find command is comprised of two main parts, the expression and the action. When we initially use find, we usually start with the expression part. This is the part that allows us to specify a filter that defines which files to select.\nA classic example would be:\n$ find Music/ -name *.mp3 -type f Music/Gustav Mahler/01 - Das Trinklied vom Jammer der Erde.mp3 Music/Gustav Mahler/02 - Der Einsame im Herbst.mp3 The action part in this example is the default action, -print. This action prints the resulting paths with newline characters in between. It’ll run if no other action is specified.\nIn contrast, the -exec action allows us to execute commands on the resulting paths. Let’s say we want to run the file command on the list of mp3 files we just found to determine their filetype. We can achieve this by running the following command:\n$ find Music/ -name *.mp3 -exec file {} \\; Music/Gustav Mahler/01 - Das Trinklied vom Jammer der Erde.mp3: Audio file with ID3 version 2.4.0, contains:MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, Stereo Let’s dissect the arguments passed to the -exec flag, which include: A command: file A placeholder: {} A command delimiter: ; Now we’ll walk through each of these three parts in-depth.\n2. The Command Any command that can be executed by our shell is acceptable here. We should note that this isn’t our shell executing the command, rather we’re using Linux’s exec directly to execute the command. This means that any shell expansion won’t work here, as we don’t have a shell. Another effect is the unavailability of shell functions or aliases.\nAs a workaround for our missing shell functions, we can export them and call bash -c with our requested function on our file. To see this in action, we’ll continue with our directory of Mahler’s mp3 files. Let’s create a shell function that shows the track name and some details about the quality:\nfunction mp3info() { TRACK_NAME=$(basename \u0026#34;$1\u0026#34;) FILE_DATA=$(file \u0026#34;$1\u0026#34; | awk -F, \u0026#39;{$1=$2=$3=$4=\u0026#34;\u0026#34;; print $0 }\u0026#39;) echo \u0026#34;${TRACK_NAME%.mp3} : $FILE_DATA\u0026#34; } If we try to run the mp3info command on all of our files, -exec will complain that it doesn’t know about mp3info:\nfind . -name \u0026#34;*.mp3\u0026#34; -exec mp3info {} \\; find: ‘mp3info’: No such file or directory As mentioned earlier, to fix this, we’ll need to export our shell function and run it as part of a spawned shell:\n$ export -f mp3info $ find . -name \u0026#34;*.mp3\u0026#34; -exec bash -c \u0026#34;mp3info \\\u0026#34;{}\\\u0026#34;\u0026#34; \\; 01 - Das Trinklied vom Jammer der Erde : 128 kbps 44.1 kHz Stereo 02 - Der Einsame im Herbst : 128 kbps 44.1 kHz Stereo 03 - Von der Jugend : 128 kbps 44.1 kHz Stereo Note that because some of our file names hold spaces, we need to quote the results placeholder.\n3. The Results Placeholder The results placeholder is denoted by two curly braces {}.\nWe can use the placeholder multiple times if necessary:\nfind . -name \u0026#34;*.mp3\u0026#34; -exec bash -c \u0026#34;basename \\\u0026#34;{}\\\u0026#34; \u0026amp;\u0026amp; file \\\u0026#34;{}\\\u0026#34; | awk -F: \u0026#39;{\\$1=\\\u0026#34;\\\u0026#34;; print \\$0 }\u0026#39;\u0026#34; \\; 01 - Das Trinklied vom Jammer der Erde.mp3 Audio file with ID3 version 2.4.0, contains MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, Stereo 02 - Der Einsame im Herbst.mp3 Audio file with ID3 version 2.4.0, contains MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, Stereo 03 - Von der Jugend.mp3 Audio file with ID3 version 2.4.0, contains MPEG ADTS, layer III, v1, 128 kbps, 44.1 kHz, Stereo In the above example, we ran both the basename, as well as the file commands. To allow us to concatenate the commands, we spawned a separate shell, as explained above.\n4. The Delimiter We need to provide the find command with a delimiter so it’ll know where our -exec arguments stop. Two types of delimiters can be provided to the -exec argument: the semi-colon(;) or the plus sign (+). As we don’t want our shell to interpret the semi-colon, we need to escape it (;).\nThe delimiter determines the way find handles the expression results. If we use the semi-colon (;), the -exec command will be repeated for each result separately. On the other hand, if we use the plus sign (+), all of the expressions’ results will be concatenated and passed as a whole to the -exec command, which will run only once.\nLet’s see the use of the plus sign with another example:\n$ find . -name \u0026#34;*.mp3\u0026#34; -exec echo {} + ./Gustav Mahler/01 - Das Trinklied vom Jammer der Erde.mp3 ./Gustav Mahler/02 - Der Einsame im Herbst.mp3 ./Gustav Mahler/03 - Von der Jugend.mp3 ./Gustav Mahler/04 - Von der Schönheit.mp3 ./Gustav Mahler/05 - Der Trunkene im Frühling.mp3 ./Gustav Mahler/06 - Der Abschied.mp3 When running echo, a newline is generated for every echo call, but since we used the plus-delimiter, only a single echo call was made. Let’s compare this result to the semi-colon version:\n$ find . -name \u0026#34;*.mp3\u0026#34; -exec echo {} \\; ./Gustav Mahler/01 - Das Trinklied vom Jammer der Erde.mp3 ./Gustav Mahler/02 - Der Einsame im Herbst.mp3 From a performance point of view, we usually prefer to use the plus-sign delimiter, as running separate processes for each file can incur a serious penalty in both RAM and processing time.\nHowever, we may prefer using the semi-colon delimiter in one of the following cases:\nThe tool run by -exec doesn’t accept multiple files as an argument. Running the tool on so many files at once might use up too much memory. We want to start getting some results as soon as possible, even though it’ll take more time to get all the results. One of the commands I use often with is\nfind my_directory/ -type f -exec lfs hsm_restore {} \\; Xargs Command There are commands that only take input as arguments like cp, rm, echo etc. We can use xargs to convert input coming from standard input to arguements.\n$find . -type f -name \u0026#34;*.log\u0026#34; | xargs -n 1 echo rm rm ./log/file5.log rm ./log/file6.log -n 1 argument, xargs turns each line into a command of its own.\n-I option takes a string that gets replaced with the supplied input before the command executes. Commond choices are {} and %.\nfind ./log -type f -name \u0026#34;*.log\u0026#34; | xargs -I % mv % backup/ aws s3 ls --recursive s3://my-bucket/ | grep \u0026#34;my_test\u0026#34; | cut -d\u0026#39; \u0026#39; -f4 | xargs -I{} aws s3 rm s3://my-bucket/{} -P option specify the number of parallel processes used in executing the commands over the input argument list.\nThe command below parallelly encodes a series of wav files to mp3 format: $find . -type f -name \u0026lsquo;*.wav\u0026rsquo; -print0 |xargs -0 -P 3 -n 1 mp3 -V8\nWhen combining find with xargs, it\u0026rsquo;s usually faster than using exec mentioned above.\nrsync command When use the following command, be careful about the relative path. In this command, we\u0026rsquo;re using 16 processes.\nls /my_model/checkpoints/source_dir | xargs -n16 -P -I% rsync -aP % target_dir Here Document/Text Tips and Tricks Sometimes we need to copy multiple files from a directory. In order to copy multiple ones without explicitly listing all the absolute paths, we can use the following way. However, to use the autocomplete, we need to type left { first without the right one. cp /root/local/libs/{a.py, b.py} target_dir Sort and Cut Sometimes we want to sort based on a specific field in string. We can use the following command\n# cut 2nd field, from 2nd field split based on equal sign and sort based on the 3rd field # cut field delimiter is -d, and sort field delimiter is -t echo xxx | grep yyy | cut -d \u0026#34; \u0026#34; -f2 | | sort -t = -k 3 -n | uniq | less How to Split Large PR Sometimes, we have a giant PR which we want to merge. Often times, it gives reviewer a lot of headache. Now we learn how to split large PR into smaller ones. Suppose our feature branch is my_feature_branch, then we can get the diff file using:\nStep 1 git diff master my_feature_branch \u0026gt; ../huge_pr_file Step 2 We switch back to master and create a new feature branch for the first small pr.\ngit checkout master git checkout -b first_small_feature_pr Step 3 Whilst on the first small feature branch, we apply all the code changes.\ngit apply ../huge_pr_file After running this command, we\u0026rsquo;ll see all the unstaged changes on the first_small_feature_pr branch. Now we can stage any files we want, commit and push them.\nStep 4 After pushing/committing the first feature pr, we can stash all the remaining changes (so that we won\u0026rsquo;t commit in this branch).\ngit stash --include-untracked --keep-index Step 5 Repeat this process from above to create a second PR. Based on the dependency or references, we might have to create a new branch based on the other small PR branch.\ngit checkout master git checkout -b second_small_feature_pr #OR git checkout first_small_feature_pr git checkout -b second_small_feature_pr ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/shell-commands/","summary":"Git Git merge Suppose we\u0026rsquo;re on master branch, if we want to override the changes in the master branch with feature branch, we can use the following command git merge -X theirs feature to keep the master branch changes: git merge -X ours feature If we want to rebase of current branch onto the master, and want to keep feature branch git rebase master -X theirs if we want to keep master branch changes over our feature branch, the git rebase master -X ours To summarize, we can have the following table: \u0026nbsp; Currently on Command \u0026nbsp; \u0026nbsp; Strategy \u0026nbsp; \u0026nbsp; Outcome \u0026nbsp;master git merge feature \u0026nbsp; -Xtheirs \u0026nbsp; \u0026nbsp; Keep changes from feature branch master git merge feature -Xours keep changes from master branch \u0026nbsp;feature git rebase master \u0026nbsp; -Xtheirs \u0026nbsp; \u0026nbsp; Keep changes from feature branch feature git","title":"Shell Commands"},{"content":"Forward and Reverse Proxy Server When clients (web browsers) make requests to sites and services on the Internet, the forward proxy server intercepts those requests and then communicates with servers on behalf of these clients like a middleman. Why we use forward proxy server?\nCircumvent restrictions. Sometimes restrictions through firewall are put on the access of the internet. A forward proxy can get around these restriction. Block contents. Proxies can be set up to block a certain type of user to access a specific type of online contents Protect online ID. A reverse proxy is an application that sits in front of back-end applications and forwards client (e.g. browser) requests to those applications. Why we use reverse proxy server?\nLoad balancing Protection from attacks Caching (such as CDN caching) SSL encryption A simplified way to sum it up would be to say that a forward proxy sits in front of a client and ensures that no origin server ever communicates directly with that specific client. On the other hand, a reverse proxy sits in front of an origin server and ensures that no client ever communicates directly with that origin server.\n","permalink":"https://rich-junwang.github.io/en-us/posts/tech/web/forward_reverse_proxy/","summary":"Forward and Reverse Proxy Server When clients (web browsers) make requests to sites and services on the Internet, the forward proxy server intercepts those requests and then communicates with servers on behalf of these clients like a middleman. Why we use forward proxy server? Circumvent restrictions. Sometimes restrictions through firewall are put on the access of the internet. A forward proxy can get around these restriction. Block contents. Proxies can be set up to block a certain type of user to access a specific type of online contents Protect online ID. A reverse proxy is an application that sits in front of back-end applications and forwards client (e.g. browser) requests to those applications. Why we use reverse proxy server? Load balancing Protection from attacks Caching (such as CDN caching) SSL encryption A simplified way to sum it up would be","title":"Basics of Web"},{"content":"Concurrency in Python Parallelism consists of performing multiple operations at the same time. Multiprocessing is a means to effect parallelism, and it entails spreading tasks over a computer’s central processing units (CPUs, or cores). Multiprocessing is well-suited for CPU-bound tasks: tightly bound for loops and mathematical computations usually fall into this category.\nConcurrency is a slightly broader term than parallelism. It suggests that multiple tasks have the ability to run in an overlapping manner. (There’s a saying that concurrency does not imply parallelism.)\nThreading is a concurrent execution model whereby multiple threads take turns executing tasks. One process can contain multiple threads. Python has a complicated relationship with threading thanks to its GIL, but that’s beyond the scope of this article.\nWhat’s important to know about threading is that it’s better for IO-bound tasks. While a CPU-bound task is characterized by the computer’s cores continually working hard from start to finish, an IO-bound job is dominated by a lot of waiting on input/output to complete.\nTo recap the above, concurrency encompasses both multiprocessing (ideal for CPU-bound tasks) and threading (suited for IO-bound tasks). Multiprocessing is a form of parallelism, with parallelism being a specific type (subset) of concurrency. The Python standard library has offered longstanding support for both of these through its multiprocessing, threading, and concurrent.futures packages.\nupdate python on ubuntu When there are multiple version of python in the system, how to set the default python to use. Below we suppose to install newer version of python3.9\nsudo apt install python3.9 sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.[old-version] 1 sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.9 2 #after the following command, select the new version when being prompted and press enter sudo update-alternatives --config python3 # There is a simpler way. From system admin perspective, this is not scalable. sudo ln -sf /usr/bin/python3.9 /usr/bin/python3 find a python package related files pip show -f package-name Find out python binry file path \u0026gt;\u0026gt;\u0026gt; import streamlit \u0026gt;\u0026gt;\u0026gt; print(streamlit.__file__) Process Got Killed Once in a while, I found my python process got killed without any errors. Most of time, it\u0026rsquo;s related to out of memory (OOM) issue. We can quickly check that using the following command\ndmesg | grep \u0026#34;oom-kill\u0026#34; | less Virtual Env python3 -m pip install \u0026ndash;upgrade pip python3 -m pip install \u0026ndash;user virtualenv python3 -m venv .venv source .venv/bin/activate\nDebug # using pdb import pdb; pdb.set_trace() Exception How to catch generic exception type\ntry: someFunction() except Exception as ex: template = \u0026#34;An exception of type {0} occurred. Arguments:\\n{1!r}\u0026#34; message = template.format(type(ex).__name__, ex.args) print(message) The difference between the above and using just except without any argument is twofold: (1) A bare except doesn\u0026rsquo;t give you the exception object to inspect (2) The exceptions SystemExit, KeyboardInterrupt and GeneratorExit aren\u0026rsquo;t caught by the above code, which is generally what you want.\nIf you also want the same stacktrace you get if you do not catch the exception, you can get that like this (still inside the except clause):\nimport traceback print(traceback.format_exc()) If you use the logging module, you can print the exception to the log (along with a message) like this:\nimport logging log = logging.getLogger() log.exception(\u0026#34;Message for you, sir!\u0026#34;) To dig deeper and examine the stack, look at variables etc., use the post_mortem function of the pdb module inside the except block:\nimport pdb pdb.post_mortem() ","permalink":"https://rich-junwang.github.io/en-us/posts/tech/programming_language/python/","summary":"Concurrency in Python Parallelism consists of performing multiple operations at the same time. Multiprocessing is a means to effect parallelism, and it entails spreading tasks over a computer’s central processing units (CPUs, or cores). Multiprocessing is well-suited for CPU-bound tasks: tightly bound for loops and mathematical computations usually fall into this category. Concurrency is a slightly broader term than parallelism. It suggests that multiple tasks have the ability to run in an overlapping manner. (There’s a saying that concurrency does not imply parallelism.) Threading is a concurrent execution model whereby multiple threads take turns executing tasks. One process can contain multiple threads. Python has a complicated relationship with threading thanks to its GIL, but that’s beyond the scope of","title":"Python"}]